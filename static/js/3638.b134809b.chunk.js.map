{"version":3,"file":"static/js/3638.b134809b.chunk.js","mappings":"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","sources":["../../../node_modules/@gmod/ucsc-hub/src/raStanza.ts","../../../node_modules/@gmod/ucsc-hub/src/raFile.ts","../../../node_modules/@gmod/ucsc-hub/src/trackDbFile.ts","../../../node_modules/@gmod/ucsc-hub/src/hubFile.ts","../../../node_modules/@gmod/ucsc-hub/src/genomesFile.ts"],"sourcesContent":["/**\n * Class representing an ra file stanza. Each stanza line is split into its key\n * and value and stored as a Map, so the usual Map methods can be used on the\n * stanza. An additional method `add()` is available to take a raw line of text\n * and break it up into a key and value and add them to the class. This should\n * be favored over `set()` when possible, as it performs more validity checks\n * than using `set()`.\n *\n * @extends Map\n * @property {undefined|string} nameKey - The key of the first line of the\n * stanza (`undefined` if the stanza has no lines yet).\n *\n * @property {undefined|string} name - The value of the first line of the\n * stanza, by which it is identified in an ra file  (`undefined` if the stanza\n * has no lines yet).\n *\n * @property {undefined|string} indent - The leading indent of the stanza,\n * which is the same for every line (`undefined` if the stanza has no lines\n * yet, `''` if there is no indent).\n *\n * @throws {Error} Throws if the stanza has blank lines, if the first line\n * doesn't have both a key and a value, if a key in the stanza is\n * duplicated, or if lines in the stanza have inconsistent indentation.\n * @param {(string|string[])} [stanza=[]] - An ra file stanza, either as a\n * string or a array of strings with one line per entry. Supports both LF and\n * CRLF line terminators.\n *\n * @param {object} options\n *\n * @param {boolean} options.checkIndent [true] - Check if a stanza is indented\n * consistently and keep track of the indentation\n */\nexport default class RaStanza extends Map<string, string> {\n  _checkIndent: boolean\n\n  _keyAndCommentOrder: string[]\n\n  _continuedLine?: string\n\n  indent?: string\n\n  name?: string\n\n  nameKey?: string\n\n  constructor(stanza: string | string[], options = { checkIndent: true }) {\n    super()\n    const { checkIndent } = options\n    this._checkIndent = checkIndent\n    let stanzaLines: string[]\n    if (typeof stanza === 'string') {\n      stanzaLines = stanza.trimEnd().split(/\\r?\\n/)\n    } else if (!stanza) {\n      stanzaLines = []\n    } else {\n      stanzaLines = stanza\n    }\n    this._keyAndCommentOrder = []\n    stanzaLines.forEach(line => {\n      this.add(line)\n    })\n  }\n\n  /**\n   * Add a single line to the stanza. If the exact line already exists, does\n   * nothing.\n   * @param {string} line A stanza line\n   * @returns {RaStanza} The RaStanza object\n   */\n  add(line: string) {\n    if (line === '') {\n      throw new Error('Invalid stanza, contained blank lines')\n    }\n    if (line.trim().startsWith('#')) {\n      this._keyAndCommentOrder.push(line.trim())\n      return this\n    }\n    if (line.trimEnd().endsWith('\\\\')) {\n      const trimmedLine = line.trimEnd().slice(0, -1)\n      if (this._continuedLine) {\n        this._continuedLine += trimmedLine.trimStart()\n      } else {\n        this._continuedLine = trimmedLine\n      }\n      return this\n    }\n    let combinedLine = line\n    if (this._continuedLine) {\n      combinedLine = this._continuedLine + combinedLine.trimStart()\n      this._continuedLine = undefined\n    }\n    if (this.indent || this._checkIndent) {\n      const indent = combinedLine.match(/^([ \\t]+)/)\n      if (this.indent === undefined) {\n        if (indent) {\n          ;[, this.indent] = indent\n        } else {\n          this.indent = ''\n        }\n      } else if (\n        (this.indent === '' && indent !== null) ||\n        (this.indent && indent && this.indent !== indent[1])\n      ) {\n        throw new Error('Inconsistent indentation of stanza')\n      }\n    } else {\n      this.indent = ''\n    }\n    const trimmedLine = combinedLine.trim()\n    const sep = trimmedLine.indexOf(' ')\n    if (sep === -1) {\n      if (!this.nameKey) {\n        throw new Error(\n          'First line in a stanza must have both a key and a value',\n        )\n      }\n      // Adding a key that already exists and has no value is a no-op\n      if (this.has(trimmedLine)) {\n        return this\n      }\n      this._keyAndCommentOrder.push(trimmedLine)\n      return super.set(trimmedLine, '')\n    }\n    const key = trimmedLine.slice(0, sep)\n    const value = trimmedLine.slice(sep + 1)\n    if (this.has(key) && value !== this.get(key)) {\n      throw new Error(\n        'Got duplicate key with a different value in stanza: ' +\n          `\"${key}\" key has both ${this.get(key)} and ${value}`,\n      )\n    }\n    this._keyAndCommentOrder.push(key)\n    if (!this.nameKey) {\n      this.nameKey = key\n      this.name = trimmedLine.slice(sep + 1)\n    }\n    return super.set(key, value)\n  }\n\n  /**\n   * Use `add()` if possible instead of this method. If using this, be aware\n   * that no checks are made for comments, indentation, duplicate keys, etc.\n   * @param {string} key The key of the stanza line\n   * @param {string} value The value of the stanza line\n   * @returns {RaStanza} The RaStanza object\n   */\n  set(key: string, value: string) {\n    if (!(typeof value === 'string')) {\n      throw new Error(`Value of ${key} must be a string, got ${typeof value}`)\n    }\n    return super.set(key, value)\n  }\n\n  /**\n   * Delete a line\n   * @param {string} key The key of the line to delete\n   * @returns {boolean} true if the deleted line existed, false if it did not\n   */\n  delete(key: string) {\n    if (key === this.nameKey) {\n      throw new Error(\n        'Cannot delete the first line in a stanza (you can still overwrite it with set()).',\n      )\n    }\n    if (this._keyAndCommentOrder.includes(key)) {\n      this._keyAndCommentOrder = this._keyAndCommentOrder.filter(\n        value => value !== key,\n      )\n    }\n    return super.delete(key)\n  }\n\n  /**\n   * Clear all lines and comments\n   */\n  clear() {\n    this._keyAndCommentOrder.length = 0\n    this._continuedLine = undefined\n    this.indent = undefined\n    this.name = undefined\n    this.nameKey = undefined\n    super.clear()\n  }\n\n  /**\n   * @returns {string} Returns the stanza as a string fit for writing to a ra\n   * file. Original leading indent is preserved. It may not be the same as the\n   * input stanza as lines that were joined with `\\` in the input will be output\n   * as a single line and all comments will have the same indentations as the\n   * rest of the stanza. Comments between joined lines will move before that\n   * line.\n   */\n  toString() {\n    if (this.size === 0) {\n      return ''\n    }\n    const lines = [] as string[]\n    this._keyAndCommentOrder.forEach(entry => {\n      if (entry.startsWith('#')) {\n        lines.push(`${this.indent}${entry}`)\n      } else {\n        lines.push(`${this.indent}${entry} ${this.get(entry)}`.trimEnd())\n      }\n    })\n    return `${lines.join('\\n')}\\n`\n  }\n}\n","import RaStanza from './raStanza'\n\n/**\n * Class representing an ra file. Each file is composed of multiple stanzas, and\n * each stanza is separated by one or more blank lines. Each stanza is stored in\n * a Map with the key being the value of the first key-value pair in the stanza.\n * The usual Map methods can be used on the file. An additional method `add()`\n * is available to take a raw line of text and break it up into a key and value\n * and add them to the class. This should be favored over `set()` when possible,\n * as it performs more validity checks than using `set()`.\n * @extends Map\n * @property {undefined|string} nameKey - The key of the first line of all the\n * stanzas (`undefined` if the stanza has no lines yet).\n * @throws {Error} Throws if an empty stanza is added, if the key in the first\n * key-value pair of each stanze isn't the same, or if two stanzas have the same\n * value for the key-value pair in their first lines.\n * @param {(string|string[])} [raFile=[]] - An ra file, either as a single\n * string or an array of strings with one stanza per entry. Supports both LF\n * and CRLF line terminators.\n * @param {object} options\n * @param {boolean} options.checkIndent [true] - Check if a the stanzas within\n * the file are indented consistently and keep track of the indentation\n */\nexport default class RaFile extends Map<string, RaStanza> {\n  _checkIndent: boolean\n\n  _stanzaAndCommentOrder: string[]\n\n  nameKey?: string\n\n  constructor(raFile: string, options = { checkIndent: true }) {\n    super()\n    const { checkIndent } = options\n    this._checkIndent = checkIndent\n    let stanzas: string[]\n    if (typeof raFile === 'string') {\n      stanzas = raFile.trimEnd().split(/(?:[\\t ]*\\r?\\n){2,}/)\n    } else if (!raFile) {\n      stanzas = []\n    } else {\n      stanzas = raFile\n    }\n    this._stanzaAndCommentOrder = []\n    stanzas.forEach(stanza => {\n      this.add(stanza)\n    })\n  }\n\n  /**\n   * Add a single stanza to the file\n   * @param {string} stanza A single stanza\n   * @returns {RaFile} The RaFile object\n   */\n  add(stanza: string) {\n    if (stanza === '') {\n      throw new Error('Invalid stanza, was empty')\n    }\n    if (stanza.trim().startsWith('#')) {\n      const stanzaLines = stanza\n        .trimEnd()\n        .split(/\\r?\\n/)\n        .map(line => line.trim())\n      if (stanzaLines.every(line => line.startsWith('#'))) {\n        this._stanzaAndCommentOrder.push(stanzaLines.join('\\n'))\n        return this\n      }\n    }\n    const raStanza = new RaStanza(stanza, { checkIndent: this._checkIndent })\n    if (!this.nameKey) {\n      this.nameKey = raStanza.nameKey\n    } else if (raStanza.nameKey !== this.nameKey) {\n      throw new Error(\n        'The first line in each stanza must have the same key. ' +\n          `Saw both ${this.nameKey} and ${raStanza.nameKey}`,\n      )\n    }\n    if (!raStanza.name) {\n      throw new Error(`No stanza name: ${raStanza.name}`)\n    }\n    if (this.has(raStanza.name)) {\n      throw new Error(`Got duplicate stanza name: ${raStanza.name}`)\n    }\n\n    this._stanzaAndCommentOrder.push(raStanza.name)\n    return super.set(raStanza.name, raStanza)\n  }\n\n  /**\n   * Use `add()` if possible instead of this method. If using this, be aware\n   * that no checks are made for comments, empty stanzas, duplicate keys, etc.\n   * @param {string} key The key of the RaFile stanza\n   * @param {RaStanza} value The RaFile stanza used to replace the prior one\n   */\n  update(key: string, value: RaStanza) {\n    if (!(value instanceof RaStanza)) {\n      throw new Error(`Value of ${key} is not an RaStanza`)\n    }\n    super.set(key, value)\n  }\n\n  /**\n   * Delete a stanza\n   * @param {string} stanza The name of the stanza to delete (the value in its\n   * first key-value pair)\n   * @returns {boolean} true if the deleted stanza existed, false if it did not\n   */\n  delete(stanza: string) {\n    if (this._stanzaAndCommentOrder.includes(stanza)) {\n      this._stanzaAndCommentOrder = this._stanzaAndCommentOrder.filter(\n        value => value !== stanza,\n      )\n    }\n    return super.delete(stanza)\n  }\n\n  /**\n   * Clear all stanzas and comments\n   */\n  clear() {\n    this._stanzaAndCommentOrder.length = 0\n    this.nameKey = undefined\n    super.clear()\n  }\n\n  /**\n   * @returns {string} Returns the stanza as a string fit for writing to a ra\n   * file. Original leading indent is preserved. It may not be the same as the\n   * input stanza as lines that were joined with `\\` in the input will be output\n   *  as a single line and all comments will have the same indentations as the\n   * rest of the stanza. Comments between joined lines will move before that\n   * line.\n   */\n  toString() {\n    if (this.size === 0) {\n      return ''\n    }\n    const stanzas = [] as string[]\n    this._stanzaAndCommentOrder.forEach(entry => {\n      if (entry.startsWith('#')) {\n        stanzas.push(`${entry}\\n`)\n      } else {\n        const e = this.get(entry)\n        if (e) {\n          stanzas.push(e.toString())\n        }\n      }\n    })\n    return stanzas.join('\\n')\n  }\n}\n","import RaFile from './raFile'\n\n/**\n * Class representing a genomes.txt file.\n * @extends RaFile\n * @param {(string|string[])} [trackDbFile=[]] - A trackDb.txt file as a string\n * @throws {Error} Throws if \"track\" is not the first key in each track or if a\n * track is missing required keys\n */\nexport default class TrackDbFile extends RaFile {\n  constructor(trackDbFile: string) {\n    super(trackDbFile, { checkIndent: false })\n    if (this.nameKey !== 'track') {\n      throw new Error(\n        `trackDb has \"${this.nameKey}\" instead of \"track\" as the first line in each track`,\n      )\n    }\n    this.forEach((track, trackName) => {\n      const trackKeys = Array.from(track.keys())\n      const missingKeys = [] as string[]\n      const requiredKeys = ['track', 'shortLabel']\n      requiredKeys.forEach(key => {\n        if (!trackKeys.includes(key)) {\n          missingKeys.push(key)\n        }\n      })\n      if (missingKeys.length > 0) {\n        throw new Error(\n          `Track ${trackName} is missing required key(s): ${missingKeys.join(\n            ', ',\n          )}`,\n        )\n      }\n      const parentTrackKeys = [\n        'superTrack',\n        'compositeTrack',\n        'container',\n        'view',\n      ]\n      if (!trackKeys.some(key => parentTrackKeys.includes(key))) {\n        if (!trackKeys.includes('bigDataUrl')) {\n          throw new Error(\n            `Track ${trackName} is missing required key \"bigDataUrl\"`,\n          )\n        }\n        if (!trackKeys.includes('type')) {\n          const settings = this.settings(trackName)\n          const settingsKeys = Array.from(settings.keys())\n          if (!settingsKeys.includes('type')) {\n            throw new Error(\n              `Neither track ${trackName} nor any of its parent tracks have the required key \"type\"`,\n            )\n          }\n        }\n      }\n      let indent = ''\n      let currentTrackName: string | undefined = trackName\n      do {\n        currentTrackName = this.get(currentTrackName)?.get('parent')\n        if (currentTrackName) {\n          ;[currentTrackName] = currentTrackName.split(' ')\n          indent += '    '\n        }\n      } while (currentTrackName)\n      const currentTrack = this.get(trackName)\n      if (currentTrack) {\n        currentTrack.indent = indent\n        this.set(trackName, currentTrack)\n      }\n    })\n  }\n\n  /**\n   * Gets all track entries including those of parent tracks, with closer\n   * entries overriding more distant ones\n   * @param {string} trackName The name of a track\n   * @throws {Error} Throws if track name does not exist in the trackDb\n   */\n  settings(trackName: string) {\n    if (!this.has(trackName)) {\n      throw new Error(`Track ${trackName} does not exist`)\n    }\n    const parentTracks = [trackName]\n    let currentTrackName: string | undefined = trackName\n    do {\n      currentTrackName = this.get(currentTrackName)?.get('parent')\n      if (currentTrackName) {\n        parentTracks.push(currentTrackName)\n      }\n    } while (currentTrackName)\n    const settings = new Map()\n    parentTracks.reverse()\n    parentTracks.forEach(parentTrack => {\n      this.get(parentTrack)?.forEach((value, key) => {\n        settings.set(key, value)\n      })\n    })\n    return settings\n  }\n}\n","import RaStanza from './raStanza'\n\n/**\n * Class representing a hub.txt file.\n * @extends RaStanza\n * @param {(string|string[])} [hubFile=[]] - A hub.txt file as a string\n * @throws {Error} Throws if the first line of the hub.txt file doesn't start\n * with \"hub <hub_name>\", if it has invalid entries, or is missing required\n * entries\n */\nexport default class HubFile extends RaStanza {\n  constructor(hubFile: string) {\n    super(hubFile)\n    if (this.nameKey !== 'hub') {\n      throw new Error('Hub file must begin with a line like \"hub <hub_name>\"')\n    }\n    const hubTxtFields = [\n      'hub',\n      'shortLabel',\n      'longLabel',\n      'genomesFile',\n      'email',\n      'descriptionUrl',\n    ]\n    const extraFields = [] as string[]\n    this.forEach((_value, key) => {\n      if (!hubTxtFields.includes(key)) {\n        extraFields.push(key)\n      }\n    })\n    if (extraFields.length > 0) {\n      throw new Error(\n        `Hub file has invalid entr${\n          extraFields.length === 1 ? 'y' : 'ies'\n        }: ${extraFields.join(', ')}`,\n      )\n    }\n    const missingFields = [] as string[]\n    hubTxtFields.forEach(field => {\n      if (field !== 'descriptionUrl' && !this.get(field)) {\n        missingFields.push(field)\n      }\n    })\n    if (missingFields.length > 0) {\n      throw new Error(\n        `Hub file is missing required entr${\n          missingFields.length === 1 ? 'y' : 'ies'\n        }: ${missingFields.join(', ')}`,\n      )\n    }\n  }\n}\n","import RaFile from './raFile'\n\n/**\n * Class representing a genomes.txt file.\n * @extends RaFile\n * @param {(string|string[])} [genomesFile=[]] - A genomes.txt file as a string\n * @throws {Error} Throws if the first line of the hub.txt file doesn't start\n * with \"genome <genome_name>\" or if it has invalid entries\n */\nexport default class GenomesFile extends RaFile {\n  constructor(genomesFile: string) {\n    super(genomesFile)\n    if (this.nameKey !== 'genome') {\n      throw new Error(\n        'Genomes file must begin with a line like \"genome <genome_name>\"',\n      )\n    }\n\n    // TODO: check if genome is hosted by UCSC and if not, require twoBitPath and groups\n    const requiredFields = [\n      'genome',\n      'trackDb',\n      // 'twoBitPath',\n      // 'groups',\n    ]\n    this.forEach((genome, genomeName) => {\n      const missingFields = [] as string[]\n      requiredFields.forEach(field => {\n        if (!genome.get(field)) {\n          missingFields.push(field)\n        }\n      })\n      if (missingFields.length > 0) {\n        throw new Error(\n          `Genomes file entry ${genomeName} is missing required entr${\n            missingFields.length === 1 ? 'y' : 'ies'\n          }: ${missingFields.join(', ')}`,\n        )\n      }\n    })\n  }\n}\n"],"names":["RaStanza","Map","constructor","stanza","options","arguments","length","undefined","checkIndent","super","stanzaLines","this","_checkIndent","trimEnd","split","_keyAndCommentOrder","forEach","line","add","Error","trim","startsWith","push","endsWith","trimmedLine","slice","_continuedLine","trimStart","combinedLine","indent","match","sep","indexOf","nameKey","has","set","key","value","get","concat","name","delete","includes","filter","clear","toString","size","lines","entry","join","RaFile","raFile","stanzas","_stanzaAndCommentOrder","map","every","raStanza","update","e","TrackDbFile","trackDbFile","track","trackName","trackKeys","Array","from","keys","missingKeys","parentTrackKeys","some","settings","currentTrackName","_a","currentTrack","parentTracks","reverse","parentTrack","HubFile","hubFile","hubTxtFields","extraFields","_value","missingFields","field","GenomesFile","genomesFile","requiredFields","genome","genomeName"],"sourceRoot":""}