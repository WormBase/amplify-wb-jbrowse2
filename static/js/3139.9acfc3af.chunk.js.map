{"version":3,"file":"static/js/3139.9acfc3af.chunk.js","mappings":"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","sources":["../../../plugins/alignments/src/SNPCoverageAdapter/generateCoverageBins.ts","../../../plugins/alignments/src/SNPCoverageAdapter/SNPCoverageAdapter.ts"],"sourcesContent":["import { AugmentedRegion as Region } from '@jbrowse/core/util/types'\nimport { Feature } from '@jbrowse/core/util/simpleFeature'\nimport { getTag, getTagAlt, shouldFetchReferenceSequence } from '../util'\nimport {\n  parseCigar,\n  getNextRefPos,\n  getModificationPositions,\n  getMethBins,\n  Mismatch,\n} from '../MismatchParser'\nimport { doesIntersect2 } from '@jbrowse/core/util'\nimport { Bin, SkipMap } from './util'\n\nfunction mismatchLen(mismatch: Mismatch) {\n  return !isInterbase(mismatch.type) ? mismatch.length : 1\n}\n\nfunction isInterbase(type: string) {\n  return type === 'softclip' || type === 'hardclip' || type === 'insertion'\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction inc(bin: any, strand: number, type: string, field: string) {\n  let thisBin = bin[type][field]\n  if (thisBin === undefined) {\n    thisBin = bin[type][field] = {\n      total: 0,\n      '-1': 0,\n      '0': 0,\n      '1': 0,\n    }\n  }\n  thisBin.total++\n  thisBin[strand]++\n}\n\nexport default async function generateCoverageBins(\n  features: Feature[],\n  region: Region,\n  opts: { bpPerPx?: number; colorBy?: { type: string; tag?: string } },\n  fetchSequence: (arg: Region) => Promise<string>,\n) {\n  const { colorBy } = opts\n  const extendedRegion = {\n    ...region,\n    start: Math.max(0, region.start - 1),\n    end: region.end + 1,\n  }\n  const binMax = Math.ceil(extendedRegion.end - extendedRegion.start)\n  const skipmap = {} as SkipMap\n  const regionSequence =\n    features.length && shouldFetchReferenceSequence(opts.colorBy?.type)\n      ? await fetchSequence(region)\n      : undefined\n\n  const bins = [] as Bin[]\n\n  for (const feature of features) {\n    const fstart = feature.get('start')\n    const fend = feature.get('end')\n    const fstrand = feature.get('strand') as -1 | 0 | 1\n    const mismatches = (feature.get('mismatches') as Mismatch[]) || []\n\n    for (let j = fstart; j < fend + 1; j++) {\n      const i = j - region.start\n      if (i >= 0 && i < binMax) {\n        if (bins[i] === undefined) {\n          bins[i] = {\n            total: 0,\n            all: 0,\n            ref: 0,\n            '-1': 0,\n            '0': 0,\n            '1': 0,\n            lowqual: {},\n            cov: {},\n            delskips: {},\n            noncov: {},\n          }\n        }\n        if (j !== fend) {\n          bins[i].total++\n          bins[i].all++\n          bins[i].ref++\n          bins[i][fstrand]++\n        }\n      }\n    }\n\n    if (colorBy?.type === 'modifications') {\n      const seq = feature.get('seq') as string | undefined\n      const mm = (getTagAlt(feature, 'MM', 'Mm') as string) || ''\n      const ops = parseCigar(feature.get('CIGAR'))\n      const fend = feature.get('end')\n      if (seq) {\n        const modifications = getModificationPositions(mm, seq, fstrand)\n        for (const { type, positions } of modifications) {\n          const mod = `mod_${type}`\n          for (const pos of getNextRefPos(ops, positions)) {\n            const epos = pos + fstart - region.start\n            if (epos >= 0 && epos < bins.length && pos + fstart < fend) {\n              if (bins[epos] === undefined) {\n                bins[epos] = {\n                  total: 0,\n                  all: 0,\n                  ref: 0,\n                  '-1': 0,\n                  '0': 0,\n                  '1': 0,\n                  lowqual: {},\n                  cov: {},\n                  delskips: {},\n                  noncov: {},\n                }\n              }\n              const bin = bins[epos]\n              if (bin) {\n                inc(bin, fstrand, 'cov', mod)\n              } else {\n                console.warn(\n                  'Undefined position in modifications snpcoverage encountered',\n                )\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (colorBy?.type === 'methylation') {\n      if (!regionSequence) {\n        throw new Error(\n          'no region sequence detected, need sequenceAdapter configuration',\n        )\n      }\n      const seq = feature.get('seq') as string | undefined\n      if (!seq) {\n        continue\n      }\n      const { methBins, methProbs } = getMethBins(feature)\n      const dels = mismatches.filter(f => f.type === 'deletion')\n\n      // methylation based coloring takes into account both reference sequence\n      // CpG detection and reads\n      for (let i = 0; i < fend - fstart; i++) {\n        const j = i + fstart\n        const l1 = regionSequence[j - region.start + 1]?.toLowerCase()\n        const l2 = regionSequence[j - region.start + 2]?.toLowerCase()\n        if (l1 === 'c' && l2 === 'g') {\n          const bin0 = bins[j - region.start]\n          const bin1 = bins[j - region.start + 1]\n          const b0 = methBins[i]\n          const b1 = methBins[i + 1]\n          const p0 = methProbs[i]\n          const p1 = methProbs[i + 1]\n\n          // color\n          if (\n            (b0 && (p0 !== undefined ? p0 > 0.5 : true)) ||\n            (b1 && (p1 !== undefined ? p1 > 0.5 : true))\n          ) {\n            if (bin0) {\n              inc(bin0, fstrand, 'cov', 'meth')\n              bin0.ref--\n              bin0[fstrand]--\n            }\n            if (bin1) {\n              inc(bin1, fstrand, 'cov', 'meth')\n              bin1.ref--\n              bin1[fstrand]--\n            }\n          } else {\n            if (bin0) {\n              if (\n                !dels?.some(d =>\n                  doesIntersect2(\n                    j,\n                    j + 1,\n                    d.start + fstart,\n                    d.start + fstart + d.length,\n                  ),\n                )\n              ) {\n                inc(bin0, fstrand, 'cov', 'unmeth')\n                bin0.ref--\n                bin0[fstrand]\n              }\n            }\n            if (bin1) {\n              if (\n                !dels?.some(d =>\n                  doesIntersect2(\n                    j + 1,\n                    j + 2,\n                    d.start + fstart,\n                    d.start + fstart + d.length,\n                  ),\n                )\n              ) {\n                inc(bin1, fstrand, 'cov', 'unmeth')\n                bin1.ref--\n                bin1[fstrand]--\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // normal SNP based coloring\n    const colorSNPs =\n      colorBy?.type !== 'modifications' && colorBy?.type !== 'methylation'\n\n    for (const mismatch of mismatches) {\n      const mstart = fstart + mismatch.start\n      const mlen = mismatchLen(mismatch)\n      const mend = mstart + mlen\n      for (let j = mstart; j < mstart + mlen; j++) {\n        const epos = j - region.start\n        if (epos >= 0 && epos < bins.length) {\n          const bin = bins[epos]\n          const { base, type } = mismatch\n          const interbase = isInterbase(type)\n          if (!interbase) {\n            bin.ref--\n            bin[fstrand]--\n          } else {\n            inc(bin, fstrand, 'noncov', type)\n          }\n\n          if (type === 'deletion' || type === 'skip') {\n            inc(bin, fstrand, 'delskips', type)\n            bin.total--\n          } else if (!interbase && colorSNPs) {\n            inc(bin, fstrand, 'cov', base)\n            bin.refbase = mismatch.altbase\n          }\n        }\n      }\n\n      if (mismatch.type === 'skip') {\n        const hash = `${mstart}_${mend}_${fstrand}`\n        if (skipmap[hash] === undefined) {\n          skipmap[hash] = {\n            feature: feature,\n            start: mstart,\n            end: mend,\n            strand: fstrand,\n            xs: getTag(feature, 'XS') || getTag(feature, 'TS'),\n            score: 0,\n          }\n        }\n        skipmap[hash].score++\n      }\n    }\n  }\n\n  return { bins, skipmap }\n}\n","import {\n  BaseFeatureDataAdapter,\n  BaseOptions,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { AugmentedRegion as Region } from '@jbrowse/core/util/types'\nimport SimpleFeature, { Feature } from '@jbrowse/core/util/simpleFeature'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport { toArray } from 'rxjs/operators'\nimport { firstValueFrom } from 'rxjs'\n\n// locals\nimport generateCoverageBins from './generateCoverageBins'\nimport { fetchSequence } from '../util'\n\nexport default class SNPCoverageAdapter extends BaseFeatureDataAdapter {\n  protected async configure() {\n    const subadapterConfig = this.getConf('subadapter')\n    const sequenceConf = subadapterConfig.sequenceAdapter\n    const dataAdapter = await this.getSubAdapter?.(subadapterConfig)\n\n    const sequenceAdapter = sequenceConf\n      ? await this.getSubAdapter?.(sequenceConf)\n      : undefined\n\n    if (!dataAdapter) {\n      throw new Error('Failed to get subadapter')\n    }\n\n    return {\n      subadapter: dataAdapter.dataAdapter as BaseFeatureDataAdapter,\n      sequenceAdapter: sequenceAdapter?.dataAdapter as\n        | BaseFeatureDataAdapter\n        | undefined,\n    }\n  }\n\n  async fetchSequence(region: Region) {\n    const { sequenceAdapter } = await this.configure()\n    if (!sequenceAdapter) {\n      return undefined\n    }\n\n    return fetchSequence(region, sequenceAdapter)\n  }\n\n  getFeatures(region: Region, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      const { subadapter } = await this.configure()\n      const feats = await firstValueFrom(\n        subadapter.getFeatures(region, opts).pipe(toArray()),\n      )\n\n      const { bins, skipmap } = await generateCoverageBins(\n        feats,\n        region,\n        opts,\n        arg => this.fetchSequence(arg),\n      )\n\n      bins.forEach((bin, index) => {\n        const start = region.start + index\n        observer.next(\n          new SimpleFeature({\n            id: `${this.id}-${start}`,\n            data: {\n              score: bin.total,\n              snpinfo: bin,\n              start,\n              end: start + 1,\n              refName: region.refName,\n            },\n          }),\n        )\n      })\n\n      // make fake features from the coverage\n      Object.entries(skipmap).forEach(([key, skip]) => {\n        observer.next(\n          new SimpleFeature({\n            id: key,\n            data: {\n              type: 'skip',\n              start: skip.start,\n              end: skip.end,\n              strand: skip.strand,\n              score: skip.score,\n              xs: skip.xs,\n            },\n          }),\n        )\n      })\n\n      observer.complete()\n    }, opts.signal)\n  }\n\n  async getMultiRegionFeatureDensityStats(\n    regions: Region[],\n    opts?: BaseOptions,\n  ) {\n    const { subadapter } = await this.configure()\n    return subadapter.getMultiRegionFeatureDensityStats(regions, opts)\n  }\n\n  async getRefNames(opts: BaseOptions = {}) {\n    const { subadapter } = await this.configure()\n    return subadapter.getRefNames(opts)\n  }\n\n  freeResources(/* { region } */): void {}\n}\n"],"names":["mismatchLen","mismatch","isInterbase","type","length","inc","bin","strand","field","thisBin","undefined","total","SNPCoverageAdapter","BaseFeatureDataAdapter","configure","_this$getSubAdapter","_this$getSubAdapter2","subadapterConfig","this","getConf","sequenceConf","sequenceAdapter","dataAdapter","getSubAdapter","call","Error","subadapter","fetchSequence","region","getFeatures","opts","arguments","ObservableCreate","async","feats","firstValueFrom","pipe","toArray","bins","skipmap","features","_opts$colorBy","colorBy","extendedRegion","start","Math","max","end","binMax","ceil","regionSequence","shouldFetchReferenceSequence","feature","fstart","get","fend","fstrand","mismatches","j","i","all","ref","lowqual","cov","delskips","noncov","seq","mm","getTagAlt","ops","parseCigar","modifications","getModificationPositions","positions","mod","concat","pos","getNextRefPos","epos","console","warn","methBins","methProbs","getMethBins","dels","filter","f","_regionSequence","_regionSequence2","l1","toLowerCase","l2","bin0","bin1","b0","b1","p0","p1","some","d","doesIntersect2","colorSNPs","mstart","mlen","mend","base","interbase","refbase","altbase","hash","xs","getTag","score","generateCoverageBins","arg","forEach","index","observer","next","SimpleFeature","id","data","snpinfo","refName","Object","entries","_ref","key","skip","complete","signal","getMultiRegionFeatureDensityStats","regions","getRefNames","freeResources"],"sourceRoot":""}