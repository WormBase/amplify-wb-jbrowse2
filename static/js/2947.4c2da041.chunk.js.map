{"version":3,"file":"static/js/2947.4c2da041.chunk.js","mappings":"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","sources":["../../../plugins/alignments/src/SNPCoverageAdapter/util.ts","../../../plugins/alignments/src/SNPCoverageAdapter/processReferenceCpGs.ts","../../../plugins/alignments/src/SNPCoverageAdapter/processModifications.ts","../../../plugins/alignments/src/SNPCoverageAdapter/processDepth.ts","../../../plugins/alignments/src/SNPCoverageAdapter/processMismatches.ts","../../../plugins/alignments/src/SNPCoverageAdapter/SNPCoverageAdapter.ts","../../../plugins/alignments/src/SNPCoverageAdapter/generateCoverageBins.ts","../../../plugins/alignments/src/shared/getMaximumModificationAtEachPosition.ts"],"sourcesContent":["import {\n  ColorBy,\n  Mismatch,\n  PreBaseCoverageBin,\n  PreBaseCoverageBinSubtypes,\n} from '../shared/types'\n\nexport interface Opts {\n  bpPerPx?: number\n  colorBy?: ColorBy\n  stopToken?: string\n}\n\nexport function mismatchLen(mismatch: Mismatch) {\n  return !isInterbase(mismatch.type) ? mismatch.length : 1\n}\n\nexport function isInterbase(type: string) {\n  return type === 'softclip' || type === 'hardclip' || type === 'insertion'\n}\n\nexport function inc(\n  bin: PreBaseCoverageBin,\n  strand: -1 | 0 | 1,\n  type: keyof PreBaseCoverageBinSubtypes,\n  field: string,\n) {\n  let thisBin = bin[type][field]\n  if (thisBin === undefined) {\n    thisBin = bin[type][field] = {\n      entryDepth: 0,\n      probabilities: [],\n      '-1': 0,\n      '0': 0,\n      '1': 0,\n    }\n  }\n  thisBin.entryDepth++\n  thisBin[strand]++\n}\n\nexport function incWithProbabilities(\n  bin: PreBaseCoverageBin,\n  strand: -1 | 0 | 1,\n  type: keyof PreBaseCoverageBinSubtypes,\n  field: string,\n  probability: number,\n) {\n  let thisBin = bin[type][field]\n  if (thisBin === undefined) {\n    thisBin = bin[type][field] = {\n      entryDepth: 0,\n      probabilities: [],\n      '-1': 0,\n      '0': 0,\n      '1': 0,\n    }\n  }\n  thisBin.entryDepth++\n  thisBin.probabilities.push(probability)\n  thisBin[strand]++\n}\n","import { AugmentedRegion as Region } from '@jbrowse/core/util/types'\nimport { doesIntersect2, Feature } from '@jbrowse/core/util'\n\n// locals\nimport { parseCigar } from '../MismatchParser'\nimport { getMethBins } from '../ModificationParser'\nimport { Mismatch, PreBaseCoverageBin } from '../shared/types'\nimport { incWithProbabilities } from './util'\n\nexport function processReferenceCpGs({\n  feature,\n  region,\n  bins,\n  regionSequence,\n}: {\n  bins: PreBaseCoverageBin[]\n  feature: Feature\n  region: Region\n  regionSequence: string\n}) {\n  const fstart = feature.get('start')\n  const fend = feature.get('end')\n  const fstrand = feature.get('strand') as -1 | 0 | 1\n  const seq = feature.get('seq') as string | undefined\n  const mismatches = (feature.get('mismatches') as Mismatch[] | undefined) ?? []\n  const r = regionSequence.toLowerCase()\n  if (seq) {\n    const cigarOps = parseCigar(feature.get('CIGAR'))\n    const { methBins, methProbs } = getMethBins(feature, cigarOps)\n    const dels = mismatches.filter(f => f.type === 'deletion')\n\n    // methylation based coloring takes into account both reference sequence\n    // CpG detection and reads\n    for (let i = 0; i < fend - fstart; i++) {\n      const j = i + fstart\n      const l1 = r[j - region.start + 1]\n      const l2 = r[j - region.start + 2]\n      if (l1 === 'c' && l2 === 'g') {\n        const bin0 = bins[j - region.start]\n        const bin1 = bins[j - region.start + 1]\n        const b0 = methBins[i]\n        const b1 = methBins[i + 1]\n        const p0 = methProbs[i]\n        const p1 = methProbs[i + 1]\n\n        // color\n        if (\n          (b0 && (p0 !== undefined ? p0 > 0.5 : true)) ||\n          (b1 && (p1 !== undefined ? p1 > 0.5 : true))\n        ) {\n          if (bin0) {\n            incWithProbabilities(bin0, fstrand, 'mods', 'cpg_meth', p0 || 0)\n            bin0.ref.entryDepth--\n            bin0.ref[fstrand]--\n          }\n          if (bin1) {\n            incWithProbabilities(bin1, fstrand, 'mods', 'cpg_meth', p1 || 0)\n            bin1.ref.entryDepth--\n            bin1.ref[fstrand]--\n          }\n        } else {\n          if (bin0) {\n            if (\n              !dels.some(d =>\n                doesIntersect2(\n                  j,\n                  j + 1,\n                  d.start + fstart,\n                  d.start + fstart + d.length,\n                ),\n              )\n            ) {\n              incWithProbabilities(\n                bin0,\n                fstrand,\n                'nonmods',\n                'cpg_unmeth',\n                1 - (p0 || 0),\n              )\n              bin0.ref.entryDepth--\n              bin0.ref[fstrand]--\n            }\n          }\n          if (bin1) {\n            if (\n              !dels.some(d =>\n                doesIntersect2(\n                  j + 1,\n                  j + 2,\n                  d.start + fstart,\n                  d.start + fstart + d.length,\n                ),\n              )\n            ) {\n              incWithProbabilities(\n                bin1,\n                fstrand,\n                'nonmods',\n                'cpg_unmeth',\n                1 - (p1 || 0),\n              )\n              bin1.ref.entryDepth--\n              bin1.ref[fstrand]--\n            }\n          }\n        }\n      }\n    }\n  }\n}\n","import { AugmentedRegion as Region } from '@jbrowse/core/util/types'\nimport { Feature, max, sum } from '@jbrowse/core/util'\n\n// locals\nimport { ColorBy, PreBaseCoverageBin } from '../shared/types'\nimport { getMaxProbModAtEachPosition } from '../shared/getMaximumModificationAtEachPosition'\nimport { incWithProbabilities } from './util'\n\nexport function processModifications({\n  feature,\n  colorBy,\n  region,\n  bins,\n  regionSequence,\n}: {\n  bins: PreBaseCoverageBin[]\n  feature: Feature\n  region: Region\n  colorBy?: ColorBy\n  regionSequence: string\n}) {\n  const fstart = feature.get('start')\n  const fstrand = feature.get('strand') as -1 | 0 | 1\n  const fend = feature.get('end')\n  const twoColor = colorBy?.modifications?.twoColor\n  const isolatedModification = colorBy?.modifications?.isolatedModification\n  getMaxProbModAtEachPosition(feature)?.forEach(\n    ({ type, prob, allProbs }, pos) => {\n      if (isolatedModification && type !== isolatedModification) {\n        return\n      }\n      const epos = pos + fstart - region.start\n      if (epos >= 0 && epos < bins.length && pos + fstart < fend) {\n        if (bins[epos] === undefined) {\n          bins[epos] = {\n            depth: 0,\n            readsCounted: 0,\n            refbase: regionSequence[epos],\n            snps: {},\n            ref: {\n              probabilities: [],\n              entryDepth: 0,\n              '-1': 0,\n              0: 0,\n              1: 0,\n            },\n            mods: {},\n            nonmods: {},\n            delskips: {},\n            noncov: {},\n          }\n        }\n\n        const s = 1 - sum(allProbs)\n        const bin = bins[epos]\n        if (twoColor && s > max(allProbs)) {\n          incWithProbabilities(bin, fstrand, 'nonmods', `nonmod_${type}`, s)\n        } else {\n          incWithProbabilities(bin, fstrand, 'mods', `mod_${type}`, prob)\n        }\n      }\n    },\n  )\n}\n","import { AugmentedRegion as Region } from '@jbrowse/core/util/types'\nimport { Feature } from '@jbrowse/core/util'\n\n// locals\nimport { PreBaseCoverageBin } from '../shared/types'\n\nexport function processDepth({\n  feature,\n  bins,\n  region,\n  regionSequence,\n}: {\n  feature: Feature\n  bins: PreBaseCoverageBin[]\n  region: Region\n  regionSequence: string\n}) {\n  const fstart = feature.get('start')\n  const fend = feature.get('end')\n  const fstrand = feature.get('strand') as -1 | 0 | 1\n  const regionLength = region.end - region.start\n  for (let j = fstart; j < fend + 1; j++) {\n    const i = j - region.start\n    if (i >= 0 && i < regionLength) {\n      if (bins[i] === undefined) {\n        bins[i] = {\n          depth: 0,\n          readsCounted: 0,\n          refbase: regionSequence[i],\n          ref: {\n            probabilities: [],\n            entryDepth: 0,\n            '-1': 0,\n            0: 0,\n            1: 0,\n          },\n          snps: {},\n          mods: {},\n          nonmods: {},\n          delskips: {},\n          noncov: {},\n        }\n      }\n      if (j !== fend) {\n        bins[i].depth++\n        bins[i].readsCounted++\n        bins[i].ref.entryDepth++\n        bins[i].ref[fstrand]++\n      }\n    }\n  }\n}\n","import { AugmentedRegion as Region } from '@jbrowse/core/util/types'\nimport { Feature } from '@jbrowse/core/util'\n\n// locals\nimport { Mismatch, PreBaseCoverageBin, SkipMap } from '../shared/types'\nimport { inc, isInterbase, mismatchLen } from './util'\n\nexport function processMismatches({\n  feature,\n  region,\n  bins,\n  skipmap,\n}: {\n  region: Region\n  bins: PreBaseCoverageBin[]\n  feature: Feature\n  skipmap: SkipMap\n}) {\n  const fstart = feature.get('start')\n  const fstrand = feature.get('strand') as -1 | 0 | 1\n  const mismatches = (feature.get('mismatches') as Mismatch[] | undefined) ?? []\n\n  // normal SNP based coloring\n  for (const mismatch of mismatches) {\n    const mstart = fstart + mismatch.start\n    const mlen = mismatchLen(mismatch)\n    const mend = mstart + mlen\n    for (let j = mstart; j < mstart + mlen; j++) {\n      const epos = j - region.start\n      if (epos >= 0 && epos < bins.length) {\n        const bin = bins[epos]!\n        const { base, type } = mismatch\n        const interbase = isInterbase(type)\n\n        if (type === 'deletion' || type === 'skip') {\n          inc(bin, fstrand, 'delskips', type)\n          bin.depth--\n        } else if (!interbase) {\n          inc(bin, fstrand, 'snps', base)\n          bin.ref.entryDepth--\n          bin.ref[fstrand]--\n        } else {\n          inc(bin, fstrand, 'noncov', type)\n        }\n      }\n    }\n\n    if (mismatch.type === 'skip') {\n      // for upper case XS and TS: reports the literal strand of the genomic\n      // transcript\n      const tags = feature.get('tags')\n      const xs = tags?.XS || tags?.TS\n      // for lower case ts from minimap2: genomic transcript flipped by read\n      // strand\n      const ts = tags?.ts\n      const effectiveStrand =\n        xs === '+'\n          ? 1\n          : xs === '-'\n            ? -1\n            : (ts === '+' ? 1 : xs === '-' ? -1 : 0) * fstrand\n      const hash = `${mstart}_${mend}_${effectiveStrand}`\n      if (skipmap[hash] === undefined) {\n        skipmap[hash] = {\n          feature: feature,\n          start: mstart,\n          end: mend,\n          strand: fstrand,\n          effectiveStrand,\n          score: 0,\n        }\n      }\n      skipmap[hash].score++\n    }\n  }\n}\n","import {\n  BaseFeatureDataAdapter,\n  BaseOptions,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { AugmentedRegion as Region } from '@jbrowse/core/util/types'\nimport SimpleFeature, { Feature } from '@jbrowse/core/util/simpleFeature'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport { toArray } from 'rxjs/operators'\nimport { firstValueFrom } from 'rxjs'\n\n// locals\nimport { fetchSequence } from '../util'\nimport { generateCoverageBins } from './generateCoverageBins'\n\nexport default class SNPCoverageAdapter extends BaseFeatureDataAdapter {\n  protected async configure() {\n    const subadapterConfig = this.getConf('subadapter')\n    const sequenceConf = subadapterConfig.sequenceAdapter\n    const dataAdapter = await this.getSubAdapter?.(subadapterConfig)\n\n    const sequenceAdapter = sequenceConf\n      ? await this.getSubAdapter?.(sequenceConf)\n      : undefined\n\n    if (!dataAdapter) {\n      throw new Error('Failed to get subadapter')\n    }\n\n    return {\n      subadapter: dataAdapter.dataAdapter as BaseFeatureDataAdapter,\n      sequenceAdapter: sequenceAdapter?.dataAdapter as\n        | BaseFeatureDataAdapter\n        | undefined,\n    }\n  }\n\n  async fetchSequence(region: Region) {\n    const { sequenceAdapter } = await this.configure()\n    if (!sequenceAdapter) {\n      return undefined\n    }\n    return fetchSequence(region, sequenceAdapter)\n  }\n\n  getFeatures(region: Region, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      const { subadapter } = await this.configure()\n      const features = await firstValueFrom(\n        subadapter.getFeatures(region, opts).pipe(toArray()),\n      )\n\n      const { bins, skipmap } = await generateCoverageBins({\n        features,\n        region,\n        opts,\n        fetchSequence: (region: Region) => this.fetchSequence(region),\n      })\n\n      bins.forEach((bin, index) => {\n        const start = region.start + index\n        observer.next(\n          new SimpleFeature({\n            id: `${this.id}-${start}`,\n            data: {\n              score: bin.depth,\n              snpinfo: bin,\n              start,\n              end: start + 1,\n              refName: region.refName,\n            },\n          }),\n        )\n      })\n\n      // make fake features from the coverage\n      Object.entries(skipmap).forEach(([key, skip]) => {\n        observer.next(\n          new SimpleFeature({\n            id: key,\n            data: {\n              type: 'skip',\n              start: skip.start,\n              end: skip.end,\n              strand: skip.strand,\n              score: skip.score,\n              effectiveStrand: skip.effectiveStrand,\n            },\n          }),\n        )\n      })\n\n      observer.complete()\n    }, opts.stopToken)\n  }\n\n  async getMultiRegionFeatureDensityStats(\n    regions: Region[],\n    opts?: BaseOptions,\n  ) {\n    const { subadapter } = await this.configure()\n    return subadapter.getMultiRegionFeatureDensityStats(regions, opts)\n  }\n\n  async getRefNames(opts: BaseOptions = {}) {\n    const { subadapter } = await this.configure()\n    return subadapter.getRefNames(opts)\n  }\n\n  freeResources(/* { region } */): void {}\n}\n","import { AugmentedRegion as Region } from '@jbrowse/core/util/types'\nimport { Feature, sum } from '@jbrowse/core/util'\nimport { checkStopToken } from '@jbrowse/core/util/stopToken'\n\n// locals\nimport { PreBaseCoverageBin, SkipMap } from '../shared/types'\nimport { processReferenceCpGs } from './processReferenceCpGs'\nimport { processModifications } from './processModifications'\nimport { processDepth } from './processDepth'\nimport { processMismatches } from './processMismatches'\nimport { Opts } from './util'\n\nexport async function generateCoverageBins({\n  fetchSequence,\n  features,\n  region,\n  opts,\n}: {\n  features: Feature[]\n  region: Region\n  opts: Opts\n  fetchSequence: (arg: Region) => Promise<string>\n}) {\n  const { stopToken, colorBy } = opts\n  const skipmap = {} as SkipMap\n  const bins = [] as PreBaseCoverageBin[]\n  const start2 = Math.max(0, region.start - 1)\n  const diff = region.start - start2\n  const regionSequence =\n    (await fetchSequence({\n      ...region,\n      start: start2,\n      end: region.end + 1,\n    })) || ''\n  let start = performance.now()\n  for (const feature of features) {\n    if (performance.now() - start > 400) {\n      checkStopToken(stopToken)\n      start = performance.now()\n    }\n    processDepth({\n      feature,\n      bins,\n      region,\n      regionSequence: regionSequence.slice(diff),\n    })\n\n    if (colorBy?.type === 'modifications') {\n      processModifications({\n        feature,\n        colorBy,\n        bins,\n        region,\n        regionSequence: regionSequence.slice(diff),\n      })\n    } else if (colorBy?.type === 'methylation') {\n      processReferenceCpGs({\n        feature,\n        bins,\n        region,\n        regionSequence,\n      })\n    }\n    processMismatches({ feature, skipmap, bins, region })\n  }\n\n  for (const bin of bins) {\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (bin) {\n      bin.mods = Object.fromEntries(\n        Object.entries(bin.mods).map(([key, val]) => {\n          return [\n            key,\n            {\n              ...val,\n              avgProbability: val.probabilities.length\n                ? sum(val.probabilities) / val.probabilities.length\n                : undefined,\n            },\n          ] as const\n        }),\n      )\n      bin.nonmods = Object.fromEntries(\n        Object.entries(bin.nonmods).map(([key, val]) => {\n          return [\n            key,\n            {\n              ...val,\n              avgProbability: val.probabilities.length\n                ? sum(val.probabilities) / val.probabilities.length\n                : undefined,\n            },\n          ] as const\n        }),\n      )\n    }\n  }\n\n  return {\n    bins,\n    skipmap,\n  }\n}\n","import { Feature } from '@jbrowse/core/util'\n// locals\nimport { getModPositions, getModProbabilities } from '../ModificationParser'\nimport { getNextRefPos, parseCigar } from '../MismatchParser'\nimport { getTagAlt } from '../util'\n\ninterface MaximumProbabilityMod {\n  type: string\n  prob: number\n  allProbs: number[]\n}\n\nexport function getMaxProbModAtEachPosition(\n  feature: Feature,\n  cigarOps?: string[],\n) {\n  const fstrand = feature.get('strand') as -1 | 0 | 1\n  const seq = feature.get('seq') as string | undefined\n  const mm = (getTagAlt(feature, 'MM', 'Mm') as string) || ''\n  const ops = cigarOps || parseCigar(feature.get('CIGAR'))\n  if (seq) {\n    const modifications = getModPositions(mm, seq, fstrand)\n    const probabilities = getModProbabilities(feature)\n    const maxProbModForPosition = [] as MaximumProbabilityMod[]\n\n    let probIndex = 0\n    for (const { type, positions } of modifications) {\n      for (const { ref, idx } of getNextRefPos(ops, positions)) {\n        const prob =\n          probabilities?.[\n            probIndex + (fstrand === -1 ? positions.length - 1 - idx : idx)\n          ] || 0\n        if (!maxProbModForPosition[ref]) {\n          maxProbModForPosition[ref] = {\n            type,\n            prob,\n            allProbs: [prob],\n          }\n        } else {\n          const old = maxProbModForPosition[ref]\n          maxProbModForPosition[ref] = {\n            allProbs: [...old.allProbs, prob],\n            prob: Math.max(old.prob, prob),\n            type: old.prob > prob ? old.type : type,\n          }\n        }\n      }\n      probIndex += positions.length\n    }\n    return maxProbModForPosition\n  }\n  return undefined\n}\n"],"names":["mismatchLen","mismatch","isInterbase","type","length","inc","bin","strand","field","thisBin","undefined","entryDepth","probabilities","incWithProbabilities","probability","push","processReferenceCpGs","feature","region","bins","regionSequence","fstart","get","fend","fstrand","seq","mismatches","r","toLowerCase","cigarOps","parseCigar","methBins","methProbs","getMethBins","dels","filter","f","i","j","l1","start","l2","bin0","bin1","b0","b1","p0","p1","ref","some","d","doesIntersect2","processModifications","colorBy","twoColor","modifications","isolatedModification","getMaxProbModAtEachPosition","forEach","prob","allProbs","pos","epos","depth","readsCounted","refbase","snps","mods","nonmods","delskips","noncov","s","sum","max","processDepth","regionLength","end","processMismatches","skipmap","mstart","mlen","mend","base","interbase","tags","xs","XS","TS","ts","effectiveStrand","hash","score","SNPCoverageAdapter","BaseFeatureDataAdapter","configure","subadapterConfig","this","getConf","sequenceConf","sequenceAdapter","dataAdapter","getSubAdapter","Error","subadapter","fetchSequence","getFeatures","opts","ObservableCreate","async","features","firstValueFrom","pipe","toArray","stopToken","start2","Math","diff","performance","now","checkStopToken","slice","Object","fromEntries","entries","map","key","val","avgProbability","generateCoverageBins","index","observer","next","SimpleFeature","id","data","snpinfo","refName","skip","complete","getMultiRegionFeatureDensityStats","regions","getRefNames","freeResources","mm","getTagAlt","ops","getModPositions","getModProbabilities","maxProbModForPosition","probIndex","positions","idx","getNextRefPos","old"],"sourceRoot":""}