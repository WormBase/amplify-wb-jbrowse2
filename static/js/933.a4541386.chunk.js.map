{"version":3,"file":"static/js/933.a4541386.chunk.js","mappings":"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","sources":["../../../node_modules/@gmod/nclist/src/util.ts","../../../node_modules/@gmod/nclist/src/nclist.ts","../../../node_modules/@gmod/nclist/src/array_representation.ts","../../../node_modules/@gmod/nclist/src/lazy_array.ts","../../../node_modules/@gmod/nclist/src/feature_store.ts","../../../node_modules/@gmod/nclist/src/index.ts","../../../node_modules/@babel/runtime/helpers/esm/OverloadYield.js","../../../node_modules/@babel/runtime/helpers/esm/asyncGeneratorDelegate.js","../../../node_modules/@babel/runtime/helpers/esm/asyncIterator.js","../../../node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator.js","../../../node_modules/@babel/runtime/helpers/esm/AsyncGenerator.js","../../../node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator.js"],"sourcesContent":["//@ts-nocheck\nexport async function readJSON(url, readFile, options = {}) {\n  const { defaultContent = {} } = options\n  let str\n  try {\n    str = await readFile(url, { encoding: 'utf8' })\n    return JSON.parse(str)\n  } catch (error) {\n    if (error.code === 'ENOENT' || error.status === 404) {\n      return defaultContent\n    }\n    throw error\n  }\n}\n\nexport function foo() {}\n","//@ts-nocheck\nimport nodeUrl from 'url'\nimport QuickLRU from 'quick-lru'\nimport AbortablePromiseCache from 'abortable-promise-cache'\nimport { readJSON } from './util'\n\nexport default class NCList {\n  constructor({ readFile, cacheSize = 100 }) {\n    this.topList = []\n    this.chunkCache = new AbortablePromiseCache({\n      cache: new QuickLRU({ maxSize: cacheSize }),\n      fill: this.readChunkItems.bind(this),\n    })\n    this.readFile = readFile\n    if (!this.readFile) {\n      throw new Error(`must provide a \"readFile\" function`)\n    }\n  }\n\n  importExisting(nclist, attrs, baseURL, lazyUrlTemplate, lazyClass) {\n    this.topList = nclist\n    this.attrs = attrs\n    this.start = attrs.makeFastGetter('Start')\n    this.end = attrs.makeFastGetter('End')\n    this.lazyClass = lazyClass\n    this.baseURL = baseURL\n    this.lazyUrlTemplate = lazyUrlTemplate\n  }\n\n  binarySearch(arr, item, getter) {\n    let low = -1\n    let high = arr.length\n    let mid\n\n    while (high - low > 1) {\n      mid = (low + high) >>> 1\n      if (getter(arr[mid]) >= item) {\n        high = mid\n      } else {\n        low = mid\n      }\n    }\n\n    // if we're iterating rightward, return the high index;\n    // if leftward, the low index\n    if (getter === this.end) {\n      return high\n    }\n    return low\n  }\n\n  readChunkItems(chunkNum) {\n    const url = nodeUrl.resolve(\n      this.baseURL,\n      this.lazyUrlTemplate.replace(/\\{Chunk\\}/gi, chunkNum),\n    )\n    return readJSON(url, this.readFile, { defaultContent: [] })\n  }\n\n  async *iterateSublist(arr, from, to, inc, searchGet, testGet, path) {\n    const getChunk = this.attrs.makeGetter('Chunk')\n    const getSublist = this.attrs.makeGetter('Sublist')\n\n    const pendingPromises = []\n    for (\n      let i = this.binarySearch(arr, from, searchGet);\n      i < arr.length && i >= 0 && inc * testGet(arr[i]) < inc * to;\n      i += inc\n    ) {\n      if (arr[i][0] === this.lazyClass) {\n        // this is a lazily-loaded chunk of the nclist\n        const chunkNum = getChunk(arr[i])\n        const chunkItemsP = this.chunkCache\n          .get(chunkNum, chunkNum)\n          .then(item => [item, chunkNum])\n        pendingPromises.push(chunkItemsP)\n      } else {\n        // this is just a regular feature\n        yield [arr[i], path.concat(i)]\n      }\n\n      // if this node has a contained sublist, process that too\n      const sublist = getSublist(arr[i])\n      if (sublist) {\n        yield* this.iterateSublist(\n          sublist,\n          from,\n          to,\n          inc,\n          searchGet,\n          testGet,\n          path.concat(i),\n        )\n      }\n    }\n\n    for (let i = 0; i < pendingPromises.length; i += 1) {\n      const [item, chunkNum] = await pendingPromises[i]\n      if (item) {\n        yield* this.iterateSublist(item, from, to, inc, searchGet, testGet, [\n          ...path,\n          chunkNum,\n        ])\n      }\n    }\n  }\n\n  async *iterate(from, to) {\n    // calls the given function once for each of the\n    // intervals that overlap the given interval\n    // if from <= to, iterates left-to-right, otherwise iterates right-to-left\n\n    // inc: iterate leftward or rightward\n    const inc = from > to ? -1 : 1\n    // searchGet: search on start or end\n    const searchGet = from > to ? this.start : this.end\n    // testGet: test on start or end\n    const testGet = from > to ? this.end : this.start\n\n    if (this.topList.length > 0) {\n      yield* this.iterateSublist(\n        this.topList,\n        from,\n        to,\n        inc,\n        searchGet,\n        testGet,\n        [0],\n      )\n    }\n  }\n\n  async histogram(from, to, numBins) {\n    // calls callback with a histogram of the feature density\n    // in the given interval\n\n    const result = new Array(numBins)\n    result.fill(0)\n    const binWidth = (to - from) / numBins\n    for await (const feat of this.iterate(from, to)) {\n      const firstBin = Math.max(0, ((this.start(feat) - from) / binWidth) | 0)\n      const lastBin = Math.min(\n        numBins,\n        ((this.end(feat) - from) / binWidth) | 0,\n      )\n      for (let bin = firstBin; bin <= lastBin; bin += 1) {\n        result[bin] += 1\n      }\n    }\n    return result\n  }\n}\n","//@ts-nocheck\n/**\n * @class ArrayRepr\n *\n * Class for operating on indexed array representations of objects.\n *\n * For example, if we have a lot of objects with similar attrbutes, e.g.:\n *\n * <pre class=\"code\">\n *     [\n *         {start: 1, end: 2, strand: -1},\n *         {start: 5, end: 6, strand: 1},\n *         ...\n *     ]\n * </pre>\n *\n * @description\n * we can represent them more compactly (e.g., in JSON) something like this:\n *\n * <pre class=\"code\">\n *     class = [\"start\", \"end\", \"strand\"]\n *     [\n *         [1, 2, -1],\n *         [5, 6, 1],\n *         ...\n *     ]\n * </pre>\n *\n * If we want to represent a few different kinds of objects in our big list,\n * we can have multiple \"class\" arrays, and tag each object to identify\n * which \"class\" array describes it.\n *\n * For example, if we have a lot of instances of a few types of objects,\n * like this:\n *\n * <pre class=\"code\">\n *     [\n *         {start: 1, end: 2, strand: 1, id: 1},\n *         {start: 5, end: 6, strand: 1, id: 2},\n *         ...\n *         {start: 10, end: 20, chunk: 1},\n *         {start: 30, end: 40, chunk: 2},\n *         ...\n *     ]\n * </pre>\n *\n * We could use the first array position to indicate the \"class\" for the\n * object, like this:\n *\n * <pre class=\"code\">\n *     classes = [[\"start\", \"end\", \"strand\", \"id\"], [\"start\", \"end\", \"chunk\"]]\n *     [\n *         [0, 1, 2, 1, 1],\n *         [0, 5, 6, 1, 2],\n *         ...\n *         [1, 10, 20, 1],\n *         [1, 30, 40, 1]\n *     ]\n * </pre>\n *\n * Also, if we occasionally want to add an ad-hoc attribute, we could just\n * stick an optional dictionary onto the end:\n *\n * <pre class=\"code\">\n *     classes = [[\"start\", \"end\", \"strand\", \"id\"], [\"start\", \"end\", \"chunk\"]]\n *     [\n *         [0, 1, 2, 1, 1],\n *         [0, 5, 6, 1, 2, {foo: 1}]\n *     ]\n * </pre>\n *\n * Given that individual objects are being represented by arrays, generic\n * code needs some way to differentiate arrays that are meant to be objects\n * from arrays that are actually meant to be arrays.\n * So for each class, we include a dict with <attribute name>: true mappings\n * for each attribute that is meant to be an array.\n *\n * Also, in cases where some attribute values are the same for all objects\n * in a particular set, it may be convenient to define a \"prototype\"\n * with default values for all objects in the set\n *\n * In the end, we get something like this:\n *\n * <pre class=\"code\">\n *     classes=[\n *         {'attributes': ['Start', 'End', 'Subfeatures'],\n *          'proto': {'Chrom': 'chr1'},\n *          'isArrayAttr': {Subfeatures: true}}\n *         ]\n * </pre>\n *\n * That's what this class facilitates.\n */\nclass ArrayRepr {\n  constructor(classes) {\n    this.classes = classes\n    this.fields = []\n    for (let cl = 0; cl < classes.length; cl += 1) {\n      this.fields[cl] = {}\n      for (let f = 0; f < classes[cl].attributes.length; f += 1) {\n        this.fields[cl][classes[cl].attributes[f]] = f + 1\n      }\n      if (classes[cl].proto === undefined) {\n        classes[cl].proto = {}\n      }\n      if (classes[cl].isArrayAttr === undefined) {\n        classes[cl].isArrayAttr = {}\n      }\n    }\n  }\n\n  /**\n   * @private\n   */\n  attrIndices(attr) {\n    return this.classes.map(\n      x =>\n        x.attributes.indexOf(attr) + 1 ||\n        x.attributes.indexOf(attr.toLowerCase()) + 1 ||\n        undefined,\n    )\n  }\n\n  get(obj, attr) {\n    if (attr in this.fields[obj[0]]) {\n      return obj[this.fields[obj[0]][attr]]\n    }\n\n    // try lowercase\n    const lcattr = attr.toLowerCase()\n    if (lcattr in this.fields[obj[0]]) {\n      return obj[this.fields[obj[0]][lcattr]]\n    }\n\n    const adhocIndex = this.classes[obj[0]].attributes.length + 1\n    if (adhocIndex >= obj.length || !(attr in obj[adhocIndex])) {\n      if (attr in this.classes[obj[0]].proto) {\n        return this.classes[obj[0]].proto[attr]\n      }\n      return undefined\n    }\n    return obj[adhocIndex][attr]\n  }\n\n  makeSetter(attr) {\n    return (obj, val) => {\n      this.set(obj, attr, val)\n    }\n  }\n\n  makeGetter(attr) {\n    return obj => {\n      return this.get(obj, attr)\n    }\n  }\n\n  makeFastGetter(attr) {\n    // can be used only if attr is guaranteed to be in\n    // the \"classes\" array for this object\n    const indices = this.attrIndices(attr)\n    return function get(obj) {\n      if (indices[obj[0]] !== undefined) {\n        return obj[indices[obj[0]]]\n      }\n      return undefined\n    }\n  }\n\n  // construct(self, obj, klass) {\n  //   const result = new Array(self.classes[klass].length)\n  //   Object.keys(obj).forEach(attr => {\n  //     this.set(result, attr, obj[attr])\n  //   })\n  //   return result\n  // }\n\n  /**\n   * Returns fast pre-compiled getter and setter functions for use with\n   * Arrays that use this representation.\n   * When the returned <code>get</code> and <code>set</code> functions are\n   * added as methods to an Array that contains data in this\n   * representation, they provide fast access by name to the data.\n   *\n   * @returns {Object} <code>{ get: function() {...}, set: function(val) {...} }</code>\n   *\n   * @example\n   * var accessors = attrs.accessors();\n   * var feature = get_feature_from_someplace();\n   * feature.get = accessors.get;\n   * // print out the feature start and end\n   * console.log( feature.get('start') + ',' + feature.get('end') );\n   */\n  accessors() {\n    if (!this._accessors) {\n      this._accessors = this._makeAccessors()\n    }\n    return this._accessors\n  }\n\n  /**\n   * @private\n   */\n  _makeAccessors() {\n    const indices = {}\n\n    const accessors = {\n      get(field) {\n        const f = this.get.field_accessors[field.toLowerCase()]\n        if (f) {\n          return f.call(this)\n        }\n        return undefined\n      },\n      set(field, val) {\n        const f = this.set.field_accessors[field]\n        if (f) {\n          return f.call(this, val)\n        }\n        return undefined\n      },\n      tags() {\n        return tags[this[0]] || []\n      },\n    }\n    accessors.get.field_accessors = {}\n    accessors.set.field_accessors = {}\n\n    // make a data structure as: { attr_name: [offset,offset,offset], }\n    // that will be convenient for finding the location of the attr\n    // for a given class like: indexForAttr{attrname}[classnum]\n    this.classes.forEach((cdef, classnum) => {\n      ;(cdef.attributes || []).forEach((attrname, offset) => {\n        indices[attrname] = indices[attrname] || []\n        indices[attrname][classnum] = offset + 1\n\n        attrname = attrname.toLowerCase()\n\n        indices[attrname] = indices[attrname] || []\n        indices[attrname][classnum] = offset + 1\n      })\n    })\n\n    // lowercase all the class attributes\n    const tags = this.classes.map(c => c.attributes)\n\n    // use that to make precalculated get and set accessors for each field\n    Object.keys(indices).forEach(attrname => {\n      const attrIndices = indices[attrname]\n      // get\n      accessors.get.field_accessors[attrname] = !attrIndices\n        ? function get() {\n            return undefined\n          }\n        : function get() {\n            return this[attrIndices[this[0]]]\n          }\n\n      // // set\n      // accessors.set.field_accessors[attrname] = !attrIndices\n      //   ? () => undefined\n      //   : v => {\n      //       this[attrIndices[this[0]]] = v\n      //       return v\n      //     }\n    })\n\n    return accessors\n  }\n}\nexport default ArrayRepr\n\n/*\n\nCopyright (c) 2007-2010 The Evolutionary Software Foundation\n\nCreated by Mitchell Skinner <mitch_skinner@berkeley.edu>\n\nThis package and its accompanying libraries are free software; you can\nredistribute it and/or modify it under the terms of the LGPL (either\nversion 2.1, or at your option, any later version) or the Artistic\nLicense 2.0.  Refer to LICENSE for the full license text.\n\n*/\n","//@ts-nocheck\nimport nodeUrl from 'url'\nimport QuickLRU from 'quick-lru'\nimport AbortablePromiseCache from 'abortable-promise-cache'\nimport { readJSON } from './util'\n\n/**\n * For a JSON array that gets too large to load in one go, this class\n * helps break it up into chunks and provides an\n * async API for using the information in the array.\n */\nexport default class LazyArray {\n  constructor(\n    { urlTemplate, chunkSize, length, cacheSize = 100, readFile },\n    baseUrl,\n  ) {\n    this.urlTemplate = urlTemplate\n    this.chunkSize = chunkSize\n    this.length = length\n    this.baseUrl = baseUrl === undefined ? '' : baseUrl\n    this.readFile = readFile\n    if (!readFile) {\n      throw new Error('must provide readFile callback')\n    }\n    this.chunkCache = new AbortablePromiseCache({\n      cache: new QuickLRU({ maxSize: cacheSize }),\n      fill: this.getChunk.bind(this),\n    })\n  }\n\n  /**\n   * call the callback on one element of the array\n   * @param i index\n   * @param callback callback, gets called with (i, value, param)\n   * @param param (optional) callback will get this as its last parameter\n   */\n  index(i, callback, param) {\n    this.range(i, i, callback, undefined, param)\n  }\n\n  /**\n   * async generator for the elements in the range [start,end]\n   *\n   * @param start index of first element to call the callback on\n   * @param end index of last element to call the callback on\n   */\n  async *range(start, end) {\n    start = Math.max(0, start)\n    end = Math.min(end, this.length - 1)\n\n    const firstChunk = Math.floor(start / this.chunkSize)\n    const lastChunk = Math.floor(end / this.chunkSize)\n\n    const chunkreadFiles = []\n    for (let chunk = firstChunk; chunk <= lastChunk; chunk += 1) {\n      chunkreadFiles.push(this.chunkCache.get(chunk, chunk))\n    }\n    for (let i = 0; i < chunkreadFiles.length; i += 1) {\n      const [chunkNumber, chunkData] = await chunkreadFiles[i]\n      yield* this.filterChunkData(start, end, chunkNumber, chunkData)\n    }\n  }\n\n  async getChunk(chunkNumber) {\n    let url = this.urlTemplate.replace(/\\{Chunk\\}/gi, chunkNumber)\n    if (this.baseUrl) {\n      url = nodeUrl.resolve(this.baseUrl, url)\n    }\n    const data = await readJSON(url, this.readFile)\n    return [chunkNumber, data]\n  }\n\n  *filterChunkData(queryStart, queryEnd, chunkNumber, chunkData) {\n    // index (in the overall lazy array) of the first position in this chunk\n    const firstIndex = chunkNumber * this.chunkSize\n    const chunkStart = Math.max(0, queryStart - firstIndex)\n    const chunkEnd = Math.min(queryEnd - firstIndex, this.chunkSize - 1)\n    for (let i = chunkStart; i <= chunkEnd; i += 1) {\n      yield [i + firstIndex, chunkData[i]]\n    }\n  }\n}\n","//@ts-nocheck\nimport nodeUrl from 'url'\nimport QuickLRU from 'quick-lru'\nimport AbortablePromiseCache from 'abortable-promise-cache'\n\nimport GenericNCList from './nclist'\nimport ArrayRepr from './array_representation'\nimport LazyArray from './lazy_array'\nimport { readJSON } from './util'\n\nfunction idfunc() {\n  return this._uniqueID\n}\nfunction parentfunc() {\n  return this._parent\n}\nfunction childrenfunc() {\n  return this.get('subfeatures')\n}\n\n/**\n * Sequence feature store using nested containment\n * lists held in JSON files that are lazily read.\n *\n * @param {object} args constructor args\n * @param {string} args.baseUrl base URL for resolving relative URLs\n * @param {string} args.urlTemplate Template string for\n *  the root file of each reference sequence. The reference sequence\n *  name will be interpolated into this string where `{refseq}` appears.\n * @param {function} args.readFile function to use for reading remote from URLs.\n */\nexport default class NCListStore {\n  constructor({ baseUrl, urlTemplate, readFile, cacheSize = 10 }) {\n    this.baseUrl = baseUrl\n    this.urlTemplates = { root: urlTemplate }\n\n    this.readFile = readFile\n    if (!this.readFile) {\n      throw new Error(`must provide a \"readFile\" function argument`)\n    }\n\n    this.dataRootCache = new AbortablePromiseCache({\n      cache: new QuickLRU({ maxSize: cacheSize }),\n      fill: this.fetchDataRoot.bind(this),\n    })\n  }\n\n  makeNCList() {\n    return new GenericNCList({ readFile: this.readFile })\n  }\n\n  loadNCList(refData, trackInfo, listUrl) {\n    refData.nclist.importExisting(\n      trackInfo.intervals.nclist,\n      refData.attrs,\n      listUrl,\n      trackInfo.intervals.urlTemplate,\n      trackInfo.intervals.lazyClass,\n    )\n  }\n\n  getDataRoot(refName) {\n    return this.dataRootCache.get(refName, refName)\n  }\n\n  fetchDataRoot(refName) {\n    const url = nodeUrl.resolve(\n      this.baseUrl,\n      this.urlTemplates.root.replace(/{\\s*refseq\\s*}/g, refName),\n    )\n\n    // fetch the trackdata\n    return readJSON(url, this.readFile).then(trackInfo =>\n      // trackInfo = JSON.parse( trackInfo );\n      this.parseTrackInfo(trackInfo, url),\n    )\n  }\n\n  parseTrackInfo(trackInfo, url) {\n    const refData = {\n      nclist: this.makeNCList(),\n      stats: {\n        featureCount: trackInfo.featureCount || 0,\n      },\n    }\n\n    if (trackInfo.intervals) {\n      refData.attrs = new ArrayRepr(trackInfo.intervals.classes)\n      this.loadNCList(refData, trackInfo, url)\n    }\n\n    const { histograms } = trackInfo\n    if (histograms && histograms.meta) {\n      for (let i = 0; i < histograms.meta.length; i += 1) {\n        histograms.meta[i].lazyArray = new LazyArray(\n          { ...histograms.meta[i].arrayParams, readFile: this.readFile },\n          url,\n        )\n      }\n      refData._histograms = histograms\n    }\n\n    // parse any strings in the histogram data that look like numbers\n    if (refData._histograms) {\n      Object.keys(refData._histograms).forEach(key => {\n        const entries = refData._histograms[key]\n        entries.forEach(entry => {\n          Object.keys(entry).forEach(key2 => {\n            if (\n              typeof entry[key2] === 'string' &&\n              String(Number(entry[key2])) === entry[key2]\n            ) {\n              entry[key2] = Number(entry[key2])\n            }\n          })\n        })\n      })\n    }\n\n    return refData\n  }\n\n  async getRegionStats(query) {\n    const data = await this.getDataRoot(query.ref)\n    return data.stats\n  }\n\n  /**\n   * fetch binned counts of feature coverage in the given region.\n   *\n   * @param {object} query\n   * @param {string} query.refName reference sequence name\n   * @param {number} query.start region start\n   * @param {number} query.end region end\n   * @param {number} query.numBins number of bins desired in the feature counts\n   * @param {number} query.basesPerBin number of bp desired in each feature counting bin\n   * @returns {object} as:\n   *    `{ bins: hist, stats: statEntry }`\n   */\n  async getRegionFeatureDensities({\n    refName,\n    start,\n    end,\n    numBins,\n    basesPerBin,\n  }) {\n    const data = await this.getDataRoot(refName)\n    if (numBins) {\n      basesPerBin = (end - start) / numBins\n    } else if (basesPerBin) {\n      numBins = Math.ceil((end - start) / basesPerBin)\n    } else {\n      throw new TypeError(\n        'numBins or basesPerBin arg required for getRegionFeatureDensities',\n      )\n    }\n\n    // pick the relevant entry in our pre-calculated stats\n    const stats = data._histograms.stats || []\n    const statEntry = stats.find(entry => entry.basesPerBin >= basesPerBin)\n\n    // The histogramMeta array describes multiple levels of histogram detail,\n    // going from the finest (smallest number of bases per bin) to the\n    // coarsest (largest number of bases per bin).\n    // We want to use coarsest histogramMeta that's at least as fine as the\n    // one we're currently rendering.\n    // TODO: take into account that the histogramMeta chosen here might not\n    // fit neatly into the current histogram (e.g., if the current histogram\n    // is at 50,000 bases/bin, and we have server histograms at 20,000\n    // and 2,000 bases/bin, then we should choose the 2,000 histogramMeta\n    // rather than the 20,000)\n    let histogramMeta = data._histograms.meta[0]\n    for (let i = 0; i < data._histograms.meta.length; i += 1) {\n      if (basesPerBin >= data._histograms.meta[i].basesPerBin) {\n        histogramMeta = data._histograms.meta[i]\n      }\n    }\n\n    // number of bins in the server-supplied histogram for each current bin\n    let binRatio = basesPerBin / histogramMeta.basesPerBin\n\n    // if the server-supplied histogram fits neatly into our requested\n    if (binRatio > 0.9 && Math.abs(binRatio - Math.round(binRatio)) < 0.0001) {\n      // console.log('server-supplied',query);\n      // we can use the server-supplied counts\n      const firstServerBin = Math.floor(start / histogramMeta.basesPerBin)\n      binRatio = Math.round(binRatio)\n      const histogram = []\n      for (let bin = 0; bin < numBins; bin += 1) {\n        histogram[bin] = 0\n      }\n\n      for await (const [i, val] of histogramMeta.lazyArray.range(\n        firstServerBin,\n        firstServerBin + binRatio * numBins - 1,\n      )) {\n        // this will count features that span the boundaries of\n        // the original histogram multiple times, so it's not\n        // perfectly quantitative.  Hopefully it's still useful, though.\n        histogram[Math.floor((i - firstServerBin) / binRatio)] += val\n      }\n      return { bins: histogram, stats: statEntry }\n    }\n    // console.log('make own',query);\n    // make our own counts\n    const hist = await data.nclist.histogram(start, end, numBins)\n    return { bins: hist, stats: statEntry }\n  }\n\n  /**\n   * Fetch features in a given region. This method is an asynchronous generator\n   * yielding feature objects.\n   *\n   * @param {object} args\n   * @param {string} args.refName reference sequence name\n   * @param {number} args.start start of region. 0-based half-open.\n   * @param {number} args.end end of region. 0-based half-open.\n   * @yields {object}\n   */\n  async *getFeatures({ refName, start, end }) {\n    const data = await this.getDataRoot(refName)\n    const accessors = data.attrs && data.attrs.accessors()\n    for await (const [feature, path] of data.nclist.iterate(start, end)) {\n      // the unique ID is a stringification of the path in the\n      // NCList where the feature lives; it's unique across the\n      // top-level NCList (the top-level NCList covers a\n      // track/chromosome combination)\n\n      // only need to decorate a feature once\n      if (!feature.decorated) {\n        const uniqueID = path.join(',')\n        this.decorateFeature(accessors, feature, `${refName},${uniqueID}`)\n      }\n      yield feature\n    }\n  }\n\n  // helper method to recursively add .get and .tags methods to a feature and its\n  // subfeatures\n  decorateFeature(accessors, feature, id, parent) {\n    feature.get = accessors.get\n    feature.tags = accessors.tags\n    feature._uniqueID = id\n    feature.id = idfunc\n    feature._parent = parent\n    feature.parent = parentfunc\n    feature.children = childrenfunc\n    ;(feature.get('subfeatures') || []).forEach((f, i) => {\n      this.decorateFeature(accessors, f, `${id}-${i}`, feature)\n    })\n    feature.decorated = true\n  }\n}\n","//@ts-nocheck\nimport NCListStore from './feature_store'\n\nexport default NCListStore\n","export default function _OverloadYield(t, e) {\n  this.v = t, this.k = e;\n}","import OverloadYield from \"./OverloadYield.js\";\nexport default function _asyncGeneratorDelegate(t) {\n  var e = {},\n    n = !1;\n  function pump(e, r) {\n    return n = !0, r = new Promise(function (n) {\n      n(t[e](r));\n    }), {\n      done: !1,\n      value: new OverloadYield(r, 1)\n    };\n  }\n  return e[\"undefined\" != typeof Symbol && Symbol.iterator || \"@@iterator\"] = function () {\n    return this;\n  }, e.next = function (t) {\n    return n ? (n = !1, t) : pump(\"next\", t);\n  }, \"function\" == typeof t[\"throw\"] && (e[\"throw\"] = function (t) {\n    if (n) throw n = !1, t;\n    return pump(\"throw\", t);\n  }), \"function\" == typeof t[\"return\"] && (e[\"return\"] = function (t) {\n    return n ? (n = !1, t) : pump(\"return\", t);\n  }), e;\n}","export default function _asyncIterator(r) {\n  var n,\n    t,\n    o,\n    e = 2;\n  for (\"undefined\" != typeof Symbol && (t = Symbol.asyncIterator, o = Symbol.iterator); e--;) {\n    if (t && null != (n = r[t])) return n.call(r);\n    if (o && null != (n = r[o])) return new AsyncFromSyncIterator(n.call(r));\n    t = \"@@asyncIterator\", o = \"@@iterator\";\n  }\n  throw new TypeError(\"Object is not async iterable\");\n}\nfunction AsyncFromSyncIterator(r) {\n  function AsyncFromSyncIteratorContinuation(r) {\n    if (Object(r) !== r) return Promise.reject(new TypeError(r + \" is not an object.\"));\n    var n = r.done;\n    return Promise.resolve(r.value).then(function (r) {\n      return {\n        value: r,\n        done: n\n      };\n    });\n  }\n  return AsyncFromSyncIterator = function AsyncFromSyncIterator(r) {\n    this.s = r, this.n = r.next;\n  }, AsyncFromSyncIterator.prototype = {\n    s: null,\n    n: null,\n    next: function next() {\n      return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments));\n    },\n    \"return\": function _return(r) {\n      var n = this.s[\"return\"];\n      return void 0 === n ? Promise.resolve({\n        value: r,\n        done: !0\n      }) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments));\n    },\n    \"throw\": function _throw(r) {\n      var n = this.s[\"return\"];\n      return void 0 === n ? Promise.reject(r) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments));\n    }\n  }, new AsyncFromSyncIterator(r);\n}","import OverloadYield from \"./OverloadYield.js\";\nexport default function _awaitAsyncGenerator(e) {\n  return new OverloadYield(e, 0);\n}","import OverloadYield from \"./OverloadYield.js\";\nexport default function AsyncGenerator(e) {\n  var r, t;\n  function resume(r, t) {\n    try {\n      var n = e[r](t),\n        o = n.value,\n        u = o instanceof OverloadYield;\n      Promise.resolve(u ? o.v : o).then(function (t) {\n        if (u) {\n          var i = \"return\" === r ? \"return\" : \"next\";\n          if (!o.k || t.done) return resume(i, t);\n          t = e[i](t).value;\n        }\n        settle(n.done ? \"return\" : \"normal\", t);\n      }, function (e) {\n        resume(\"throw\", e);\n      });\n    } catch (e) {\n      settle(\"throw\", e);\n    }\n  }\n  function settle(e, n) {\n    switch (e) {\n      case \"return\":\n        r.resolve({\n          value: n,\n          done: !0\n        });\n        break;\n      case \"throw\":\n        r.reject(n);\n        break;\n      default:\n        r.resolve({\n          value: n,\n          done: !1\n        });\n    }\n    (r = r.next) ? resume(r.key, r.arg) : t = null;\n  }\n  this._invoke = function (e, n) {\n    return new Promise(function (o, u) {\n      var i = {\n        key: e,\n        arg: n,\n        resolve: o,\n        reject: u,\n        next: null\n      };\n      t ? t = t.next = i : (r = t = i, resume(e, n));\n    });\n  }, \"function\" != typeof e[\"return\"] && (this[\"return\"] = void 0);\n}\nAsyncGenerator.prototype[\"function\" == typeof Symbol && Symbol.asyncIterator || \"@@asyncIterator\"] = function () {\n  return this;\n}, AsyncGenerator.prototype.next = function (e) {\n  return this._invoke(\"next\", e);\n}, AsyncGenerator.prototype[\"throw\"] = function (e) {\n  return this._invoke(\"throw\", e);\n}, AsyncGenerator.prototype[\"return\"] = function (e) {\n  return this._invoke(\"return\", e);\n};","import AsyncGenerator from \"./AsyncGenerator.js\";\nexport default function _wrapAsyncGenerator(fn) {\n  return function () {\n    return new AsyncGenerator(fn.apply(this, arguments));\n  };\n}"],"names":["readJSON","_x","_x2","_readJSON","_asyncToGenerator","_regeneratorRuntime","mark","_callee","url","readFile","_options$defaultConte","defaultContent","str","_args","arguments","wrap","_context","prev","next","length","undefined","encoding","sent","abrupt","JSON","parse","t0","code","status","stop","apply","NCList","_histogram","_ref","_ref$cacheSize","cacheSize","_classCallCheck","this","topList","chunkCache","AbortablePromiseCache","cache","QuickLRU","maxSize","fill","readChunkItems","bind","Error","_createClass","key","value","nclist","attrs","baseURL","lazyUrlTemplate","lazyClass","start","makeFastGetter","end","arr","item","getter","mid","low","high","chunkNum","nodeUrl","replace","from","to","inc","searchGet","testGet","path","_this","_wrapAsyncGenerator","getChunk","getSublist","pendingPromises","_loop","i","_i","_yield$_awaitAsyncGen","_yield$_awaitAsyncGen2","_context2","makeGetter","_chunkNum","chunkItemsP","sublist","get","then","push","concat","delegateYield","_asyncGeneratorDelegate","_asyncIterator","iterateSublist","_awaitAsyncGenerator","binarySearch","_slicedToArray","_toConsumableArray","_this2","_callee2","_context3","_x3","_callee3","numBins","result","binWidth","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_step","feat","firstBin","lastBin","bin","_context4","Array","iterate","done","Math","max","min","return","finish","ArrayRepr","classes","fields","cl","f","attributes","proto","isArrayAttr","attr","map","x","indexOf","toLowerCase","obj","lcattr","adhocIndex","val","set","indices","attrIndices","_accessors","_makeAccessors","accessors","field","field_accessors","call","tags","forEach","cdef","classnum","attrname","offset","c","Object","keys","LazyArray","_getChunk","baseUrl","urlTemplate","chunkSize","callback","param","range","firstChunk","lastChunk","chunkreadFiles","chunk","chunkNumber","chunkData","floor","filterChunkData","data","queryStart","queryEnd","firstIndex","chunkStart","chunkEnd","idfunc","_uniqueID","parentfunc","_parent","childrenfunc","NCListStore","_getRegionStats","_getRegionFeatureDensities","urlTemplates","root","dataRootCache","fetchDataRoot","GenericNCList","refData","trackInfo","listUrl","importExisting","intervals","refName","parseTrackInfo","makeNCList","stats","featureCount","loadNCList","histograms","meta","lazyArray","_objectSpread","arrayParams","_histograms","entry","key2","String","Number","query","getDataRoot","ref","_ref2","basesPerBin","statEntry","histogramMeta","binRatio","firstServerBin","histogram","_step$value","hist","ceil","TypeError","find","abs","round","bins","_ref3","_iteratorAbruptCompletion2","_didIteratorError2","_iteratorError2","_iterator2","_step2","_step2$value","feature","uniqueID","decorated","join","decorateFeature","id","parent","_this3","children","_OverloadYield","t","e","v","k","n","pump","r","Promise","Symbol","iterator","o","asyncIterator","AsyncFromSyncIterator","AsyncFromSyncIteratorContinuation","reject","resolve","s","prototype","AsyncGenerator","resume","u","OverloadYield","settle","arg","_invoke","fn"],"sourceRoot":""}