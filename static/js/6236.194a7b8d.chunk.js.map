{"version":3,"file":"static/js/6236.194a7b8d.chunk.js","mappings":"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","sources":["../../../plugins/alignments/src/CramAdapter/CramSlightlyLazyFeature.ts","../../../plugins/alignments/src/CramAdapter/util.ts","../../../plugins/alignments/src/CramAdapter/CramAdapter.ts"],"sourcesContent":["/* eslint-disable no-underscore-dangle */\nimport {\n  Feature,\n  SimpleFeatureSerialized,\n} from '@jbrowse/core/util/simpleFeature'\nimport { CramRecord } from '@gmod/cram'\n\n// locals\nimport CramAdapter from './CramAdapter'\nimport { readFeaturesToCIGAR, readFeaturesToMismatches } from './util'\n\nexport default class CramSlightlyLazyFeature implements Feature {\n  // uses parameter properties to automatically create fields on the class\n  // https://www.typescriptlang.org/docs/handbook/classes.html#parameter-properties\n  constructor(\n    private record: CramRecord,\n    private _store: CramAdapter,\n  ) {}\n\n  _get_name() {\n    return this.record.readName\n  }\n\n  _get_start() {\n    return this.record.alignmentStart - 1\n  }\n\n  _get_end() {\n    return this.record.alignmentStart + (this.record.lengthOnRef ?? 1) - 1\n  }\n\n  _get_cram_read_features() {\n    return this.record.readFeatures\n  }\n\n  _get_type() {\n    return 'match'\n  }\n\n  _get_score() {\n    return this.record.mappingQuality\n  }\n\n  _get_flags() {\n    return this.record.flags\n  }\n\n  _get_strand() {\n    return this.record.isReverseComplemented() ? -1 : 1\n  }\n\n  _read_group_id() {\n    return this._store.samHeader.readGroups?.[this.record.readGroupId]\n  }\n\n  _get_qual() {\n    return (this.record.qualityScores || []).join(' ')\n  }\n\n  qualRaw() {\n    return this.record.qualityScores\n  }\n\n  _get_refName() {\n    return this._store.refIdToName(this.record.sequenceId)\n  }\n\n  _get_is_paired() {\n    return !!this.record.mate\n  }\n\n  _get_pair_orientation() {\n    return this.record.isPaired() ? this.record.getPairOrientation() : undefined\n  }\n\n  _get_template_length() {\n    return this.record.templateLength || this.record.templateSize\n  }\n\n  _get_next_ref() {\n    return this.record.mate\n      ? this._store.refIdToName(this.record.mate.sequenceId)\n      : undefined\n  }\n\n  _get_next_segment_position() {\n    return this.record.mate\n      ? `${this._store.refIdToName(this.record.mate.sequenceId)}:${\n          this.record.mate.alignmentStart\n        }`\n      : undefined\n  }\n\n  _get_next_pos() {\n    return this.record.mate?.alignmentStart\n  }\n\n  _get_tags() {\n    const RG = this._read_group_id()\n    const { tags } = this.record\n    // avoids a tag copy if no RG, but just copy if there is one\n    return RG !== undefined ? { ...tags, RG } : tags\n  }\n\n  _get_seq() {\n    return this.record.getReadBases()\n  }\n\n  // generate a CIGAR, based on code from jkbonfield\n  _get_CIGAR() {\n    return readFeaturesToCIGAR(\n      this.record.readFeatures,\n      this.record.alignmentStart,\n      this.record.readLength,\n      this.record._refRegion,\n    )\n  }\n\n  tags() {\n    return Object.getOwnPropertyNames(CramSlightlyLazyFeature.prototype)\n      .filter(\n        prop =>\n          prop.startsWith('_get_') &&\n          prop !== '_get_mismatches' &&\n          prop !== '_get_cram_read_features',\n      )\n      .map(methodName => methodName.replace('_get_', ''))\n  }\n\n  id() {\n    return `${this._store.id}-${this.record.uniqueId}`\n  }\n\n  get(field: string) {\n    const methodName = `_get_${field}`\n    // @ts-expect-error\n    if (this[methodName]) {\n      // @ts-expect-error\n      return this[methodName]()\n    }\n    return undefined\n  }\n\n  parent() {\n    return undefined\n  }\n\n  children() {\n    return undefined\n  }\n\n  set() {}\n\n  pairedFeature() {\n    return false\n  }\n\n  _get_clipPos() {\n    const mismatches = this.get('mismatches')\n    if (mismatches.length) {\n      const record =\n        this.get('strand') === -1 ? mismatches.at(-1) : mismatches[0]\n      const { type, cliplen } = record\n      if (type === 'softclip' || type === 'hardclip') {\n        return cliplen\n      }\n    }\n    return 0\n  }\n\n  toJSON(): SimpleFeatureSerialized {\n    return {\n      ...Object.fromEntries(\n        this.tags()\n          .map(t => [t, this.get(t)])\n          .filter(elt => elt[1] !== undefined),\n      ),\n      uniqueId: this.id(),\n    }\n  }\n\n  _get_mismatches() {\n    const readFeatures = this.record.readFeatures\n    const qual = this.qualRaw()\n    const start = this.get('start')\n    return readFeaturesToMismatches(readFeatures, start, qual)\n  }\n}\n","import { CramRecord } from '@gmod/cram'\n\ntype ReadFeatures = CramRecord['readFeatures']\n\nexport interface Mismatch {\n  qual?: number\n  start: number\n  length: number\n  type: string\n  base: string | undefined\n  altbase?: string\n  seq?: string\n  cliplen?: number\n}\n\nexport function readFeaturesToMismatches(\n  readFeatures: ReadFeatures,\n  start: number,\n  qual?: number[] | null,\n) {\n  if (!readFeatures) {\n    return []\n  }\n  const mismatches: Mismatch[] = new Array(readFeatures.length)\n  let j = 0\n  let insLen = 0\n  let refPos = 0\n  let sublen = 0\n  let lastPos = start\n\n  for (const { refPos: p, code, pos, data, sub, ref } of readFeatures) {\n    sublen = refPos - lastPos\n    lastPos = refPos\n\n    if (sublen && insLen > 0) {\n      mismatches[j++] = {\n        start: refPos,\n        type: 'insertion',\n        base: `${insLen}`,\n        length: 0,\n      }\n      insLen = 0\n    }\n    refPos = p - 1 - start\n\n    if (code === 'X') {\n      // substitution\n      mismatches[j++] = {\n        start: refPos,\n        length: 1,\n        base: sub,\n        qual: qual?.[pos - 1],\n        altbase: ref?.toUpperCase(),\n        type: 'mismatch',\n      }\n    } else if (code === 'I') {\n      // insertion\n      mismatches[j++] = {\n        start: refPos,\n        type: 'insertion',\n        base: `${data.length}`,\n        length: 0,\n      }\n    } else if (code === 'N') {\n      // reference skip\n      mismatches[j++] = {\n        type: 'skip',\n        length: data,\n        start: refPos,\n        base: 'N',\n      }\n    } else if (code === 'S') {\n      // soft clip\n      const len = data.length\n      mismatches[j++] = {\n        start: refPos,\n        type: 'softclip',\n        base: `S${len}`,\n        cliplen: len,\n        length: 1,\n      }\n    } else if (code === 'P') {\n      // padding\n    } else if (code === 'H') {\n      // hard clip\n      const len = data\n      mismatches[j++] = {\n        start: refPos,\n        type: 'hardclip',\n        base: `H${len}`,\n        cliplen: len,\n        length: 1,\n      }\n    } else if (code === 'D') {\n      // deletion\n      mismatches[j++] = {\n        type: 'deletion',\n        length: data,\n        start: refPos,\n        base: '*',\n      }\n    } else if (code === 'b') {\n      // stretch of bases\n    } else if (code === 'q') {\n      // stretch of qual scores\n    } else if (code === 'B') {\n      // a pair of [base, qual]\n    } else if (code === 'i') {\n      // single-base insertion, we collect these if there are multiple in a row\n      // into a single insertion entry\n      insLen++\n    } else if (code === 'Q') {\n      // single quality value\n    }\n  }\n\n  if (sublen && insLen > 0) {\n    mismatches[j++] = {\n      start: refPos,\n      type: 'insertion',\n      base: `${insLen}`,\n      length: 0,\n    }\n    insLen = 0\n  }\n\n  return mismatches.slice(0, j)\n}\n\nexport function readFeaturesToCIGAR(\n  readFeatures: ReadFeatures,\n  alignmentStart: number,\n  readLen: number,\n  refRegion?: { seq: string; start: number },\n) {\n  let seq = ''\n  let cigar = ''\n  let op = 'M'\n  let oplen = 0\n  if (!refRegion) {\n    return ''\n  }\n\n  // not sure I should access these, but...\n  const ref = refRegion.seq\n  const refStart = refRegion.start\n  let lastPos = alignmentStart\n  let sublen = 0\n  let insLen = 0\n  if (readFeatures !== undefined) {\n    for (const { code, refPos, sub, data } of readFeatures) {\n      sublen = refPos - lastPos\n      seq += ref.slice(lastPos - refStart, refPos - refStart)\n      lastPos = refPos\n\n      if (insLen > 0 && sublen) {\n        cigar += `${insLen}I`\n        insLen = 0\n      }\n      if (oplen && op !== 'M') {\n        cigar += `${oplen}${op}`\n        oplen = 0\n      }\n      if (sublen) {\n        op = 'M'\n        oplen += sublen\n      }\n\n      if (code === 'b') {\n        // An array of bases stored verbatim\n        const ret = data.split(',')\n        const added = String.fromCharCode(...ret)\n        seq += added\n        lastPos += added.length\n        oplen += added.length\n      } else if (code === 'B') {\n        // Single base (+ qual score)\n        seq += sub\n        lastPos++\n        oplen++\n      } else if (code === 'X') {\n        // Substitution\n        seq += sub\n        lastPos++\n        oplen++\n      } else if (code === 'D' || code === 'N') {\n        // Deletion or Ref Skip\n        lastPos += data\n        if (oplen) {\n          cigar += `${oplen}${op}`\n        }\n        cigar += data + code\n        oplen = 0\n      } else if (code === 'I' || code === 'S') {\n        // Insertion or soft-clip\n        seq += data\n        if (oplen) {\n          cigar += `${oplen}${op}`\n        }\n        cigar += data.length + code\n        oplen = 0\n      } else if (code === 'i') {\n        // Single base insertion\n        // seq += data\n        if (oplen) {\n          cigar += `${oplen}${op}`\n        }\n        insLen++\n        seq += data\n        oplen = 0\n      } else if (code === 'P') {\n        // Padding\n        if (oplen) {\n          cigar += `${oplen}${op}`\n        }\n        cigar += `${data}P`\n      } else if (code === 'H') {\n        // Hard clip\n        if (oplen) {\n          cigar += `${oplen}${op}`\n        }\n        cigar += `${data}H`\n        oplen = 0\n      } // else q or Q\n    }\n  } else {\n    sublen = readLen - seq.length\n  }\n  if (seq.length !== readLen) {\n    sublen = readLen - seq.length\n    seq += ref.slice(lastPos - refStart, lastPos - refStart + sublen)\n\n    if (oplen && op !== 'M') {\n      cigar += `${oplen}${op}`\n      oplen = 0\n    }\n    op = 'M'\n    oplen += sublen\n  }\n  if (sublen && insLen > 0) {\n    cigar += `${insLen}I`\n  }\n  if (oplen) {\n    cigar += `${oplen}${op}`\n  }\n\n  return cigar\n}\n","import { CraiIndex, IndexedCramFile, CramRecord } from '@gmod/cram'\nimport {\n  BaseFeatureDataAdapter,\n  BaseOptions,\n  BaseSequenceAdapter,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport {\n  checkAbortSignal,\n  Region,\n  Feature,\n  updateStatus,\n} from '@jbrowse/core/util'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport { toArray } from 'rxjs/operators'\nimport { firstValueFrom } from 'rxjs'\n\n// locals\nimport CramSlightlyLazyFeature from './CramSlightlyLazyFeature'\nimport { IFilter } from '../shared'\n\ninterface Header {\n  idToName?: string[]\n  nameToId?: Record<string, number>\n  readGroups?: (string | undefined)[]\n}\n\nexport default class CramAdapter extends BaseFeatureDataAdapter {\n  samHeader: Header = {}\n\n  private setupP?: Promise<{\n    samHeader: Header\n    cram: IndexedCramFile\n    sequenceAdapter: BaseSequenceAdapter\n  }>\n\n  private configureP?: Promise<{\n    cram: IndexedCramFile\n    sequenceAdapter: BaseSequenceAdapter\n  }>\n\n  // maps a refname to an id\n  private seqIdToRefName: string[] | undefined\n\n  // maps a seqId to original refname, passed specially to render args, to a seqid\n  private seqIdToOriginalRefName: string[] = []\n\n  public async configurePre() {\n    const cramLocation = this.getConf('cramLocation')\n    const craiLocation = this.getConf('craiLocation')\n    if (!cramLocation) {\n      throw new Error('missing cramLocation argument')\n    }\n    if (!craiLocation) {\n      throw new Error('missing craiLocation argument')\n    }\n    const pm = this.pluginManager\n\n    const cram = new IndexedCramFile({\n      cramFilehandle: openLocation(cramLocation, pm),\n      index: new CraiIndex({ filehandle: openLocation(craiLocation, pm) }),\n      seqFetch: (...args) => this.seqFetch(...args),\n      checkSequenceMD5: false,\n      fetchSizeLimit: 200_000_000, // just make this a large size to avoid hitting it\n    })\n\n    if (!this.getSubAdapter) {\n      throw new Error('Error getting subadapter')\n    }\n\n    const seqConf = this.getConf('sequenceAdapter')\n    const subadapter = await this.getSubAdapter(seqConf)\n\n    return {\n      cram,\n      sequenceAdapter: subadapter.dataAdapter as BaseSequenceAdapter,\n    }\n  }\n\n  public async configure() {\n    if (!this.configureP) {\n      this.configureP = this.configurePre().catch(e => {\n        this.configureP = undefined\n        throw e\n      })\n    }\n    return this.configureP\n  }\n\n  async getHeader(_opts?: BaseOptions) {\n    const { cram } = await this.configure()\n    return cram.cram.getHeaderText()\n  }\n\n  private async seqFetch(\n    seqId: number,\n    start: number,\n    end: number,\n  ): Promise<string> {\n    start -= 1 // convert from 1-based closed to interbase\n\n    const { sequenceAdapter } = await this.configure()\n    const refName = this.refIdToOriginalName(seqId) || this.refIdToName(seqId)\n    if (!refName) {\n      throw new Error('unknown')\n    }\n\n    const seqChunks = await firstValueFrom(\n      sequenceAdapter\n        .getFeatures({\n          refName,\n          start,\n          end,\n          assemblyName: '',\n        })\n        .pipe(toArray()),\n    )\n\n    const sequence = seqChunks\n      .sort((a, b) => a.get('start') - b.get('start'))\n      .map(chunk => {\n        const chunkStart = chunk.get('start')\n        const chunkEnd = chunk.get('end')\n        const trimStart = Math.max(start - chunkStart, 0)\n        const trimEnd = Math.min(end - chunkStart, chunkEnd - chunkStart)\n        const trimLength = trimEnd - trimStart\n        const chunkSeq = chunk.get('seq') || chunk.get('residues')\n        return chunkSeq.slice(trimStart, trimStart + trimLength)\n      })\n      .join('')\n\n    if (sequence.length !== end - start) {\n      throw new Error(\n        `sequence fetch failed: fetching ${refName}:${(\n          start - 1\n        ).toLocaleString()}-${end.toLocaleString()} returned ${sequence.length.toLocaleString()} bases, but should have returned ${(\n          end - start\n        ).toLocaleString()}`,\n      )\n    }\n    return sequence\n  }\n\n  private async setupPre(opts?: BaseOptions) {\n    const { statusCallback = () => {} } = opts || {}\n    return updateStatus('Downloading index', statusCallback, async () => {\n      const conf = await this.configure()\n      const { cram } = conf\n      const samHeader = await cram.cram.getSamHeader()\n\n      // use the @SQ lines in the header to figure out the\n      // mapping between ref ID numbers and names\n      const idToName: string[] = []\n      const nameToId: Record<string, number> = {}\n      samHeader\n        .filter(l => l.tag === 'SQ')\n        .forEach((sqLine, refId) => {\n          sqLine.data.forEach(item => {\n            if (item.tag === 'SN') {\n              // this is the ref name\n              const refName = item.value\n              nameToId[refName] = refId\n              idToName[refId] = refName\n            }\n          })\n        })\n\n      const readGroups = samHeader\n        .filter(l => l.tag === 'RG')\n        .map(rgLine => rgLine.data.find(item => item.tag === 'ID')?.value)\n\n      const data = { idToName, nameToId, readGroups }\n      this.samHeader = data\n      return { samHeader: data, ...conf }\n    })\n  }\n\n  private async setup(opts?: BaseOptions) {\n    if (!this.setupP) {\n      this.setupP = this.setupPre(opts).catch(e => {\n        this.setupP = undefined\n        throw e\n      })\n    }\n    return this.setupP\n  }\n\n  async getRefNames(opts?: BaseOptions) {\n    const { samHeader } = await this.setup(opts)\n    if (!samHeader.idToName) {\n      throw new Error('CRAM file has no header lines')\n    }\n    return samHeader.idToName\n  }\n\n  // use info from the SAM header if possible, but fall back to using\n  // the ref seq order from when the browser's refseqs were loaded\n  refNameToId(refName: string) {\n    if (this.samHeader.nameToId) {\n      return this.samHeader.nameToId[refName]\n    }\n    if (this.seqIdToRefName) {\n      return this.seqIdToRefName.indexOf(refName)\n    }\n    return undefined\n  }\n\n  // use info from the SAM header if possible, but fall back to using\n  // the ref seq order from when the browser's refseqs were loaded\n  refIdToName(refId: number) {\n    return this.samHeader.idToName?.[refId] || this.seqIdToRefName?.[refId]\n  }\n\n  refIdToOriginalName(refId: number) {\n    return this.seqIdToOriginalRefName[refId]\n  }\n\n  getFeatures(\n    region: Region & { originalRefName?: string },\n    opts?: BaseOptions & {\n      filterBy: IFilter\n    },\n  ) {\n    const { signal, filterBy, statusCallback = () => {} } = opts || {}\n    const { refName, start, end, originalRefName } = region\n\n    return ObservableCreate<Feature>(async observer => {\n      const { cram } = await this.setup(opts)\n\n      const refId = this.refNameToId(refName)\n      if (refId === undefined) {\n        console.warn('Unknown refName', refName)\n        observer.complete()\n        return\n      }\n\n      if (originalRefName) {\n        this.seqIdToOriginalRefName[refId] = originalRefName\n      }\n      const records = await updateStatus(\n        'Downloading alignments',\n        statusCallback,\n        () => cram.getRecordsForRange(refId, start, end),\n      )\n      checkAbortSignal(signal)\n      await updateStatus('Processing alignments', statusCallback, () => {\n        const {\n          flagInclude = 0,\n          flagExclude = 0,\n          tagFilter,\n          readName,\n        } = filterBy || {}\n\n        for (const record of records) {\n          const flags = record.flags\n          if ((flags & flagInclude) !== flagInclude && !(flags & flagExclude)) {\n            continue\n          }\n\n          if (tagFilter) {\n            const v =\n              tagFilter.tag === 'RG'\n                ? this.samHeader.readGroups?.[record.readGroupId]\n                : record.tags[tagFilter.tag]\n            if (!(v === '*' ? v !== undefined : `${v}` === tagFilter.value)) {\n              continue\n            }\n          }\n\n          if (readName && record.readName !== readName) {\n            continue\n          }\n          observer.next(this.cramRecordToFeature(record))\n        }\n\n        observer.complete()\n      })\n    }, signal)\n  }\n\n  freeResources(/* { region } */): void {}\n\n  cramRecordToFeature(record: CramRecord) {\n    return new CramSlightlyLazyFeature(record, this)\n  }\n\n  // we return the configured fetchSizeLimit, and the bytes for the region\n  async getMultiRegionFeatureDensityStats(\n    regions: Region[],\n    opts?: BaseOptions,\n  ) {\n    const bytes = await this.bytesForRegions(regions, opts)\n    const fetchSizeLimit = this.getConf('fetchSizeLimit')\n    return {\n      bytes,\n      fetchSizeLimit,\n    }\n  }\n\n  /**\n   * get the approximate number of bytes queried from the file for the given\n   * query regions\n   * @param regions - list of query regions\n   */\n  private async bytesForRegions(regions: Region[], _opts?: BaseOptions) {\n    const { cram } = await this.configure()\n    const blockResults = await Promise.all(\n      regions.map(region => {\n        const { refName, start, end } = region\n        const chrId = this.refNameToId(refName)\n        return chrId !== undefined\n          ? cram.index.getEntriesForRange(chrId, start, end)\n          : [{ sliceBytes: 0 }]\n      }),\n    )\n\n    return blockResults.flat().reduce((a, b) => a + b.sliceBytes, 0)\n  }\n}\n"],"names":["CramSlightlyLazyFeature","constructor","record","_store","_get_name","this","readName","_get_start","alignmentStart","_get_end","_this$record$lengthOn","lengthOnRef","_get_cram_read_features","readFeatures","_get_type","_get_score","mappingQuality","_get_flags","flags","_get_strand","isReverseComplemented","_read_group_id","_this$_store$samHeade","samHeader","readGroups","readGroupId","_get_qual","qualityScores","join","qualRaw","_get_refName","refIdToName","sequenceId","_get_is_paired","mate","_get_pair_orientation","isPaired","getPairOrientation","undefined","_get_template_length","templateLength","templateSize","_get_next_ref","_get_next_segment_position","concat","_get_next_pos","_this$record$mate","_get_tags","RG","tags","_get_seq","getReadBases","_get_CIGAR","readLen","refRegion","seq","cigar","op","oplen","ref","refStart","start","lastPos","sublen","insLen","code","refPos","sub","data","slice","ret","split","added","String","fromCharCode","length","readFeaturesToCIGAR","readLength","_refRegion","Object","getOwnPropertyNames","prototype","filter","prop","startsWith","map","methodName","replace","id","uniqueId","get","field","parent","children","set","pairedFeature","_get_clipPos","mismatches","at","type","cliplen","toJSON","fromEntries","t","elt","_get_mismatches","qual","Array","j","p","pos","base","altbase","toUpperCase","len","readFeaturesToMismatches","CramAdapter","BaseFeatureDataAdapter","arguments","setupP","configureP","seqIdToRefName","seqIdToOriginalRefName","configurePre","_this","cramLocation","getConf","craiLocation","Error","pm","pluginManager","cram","IndexedCramFile","cramFilehandle","openLocation","index","CraiIndex","filehandle","seqFetch","checkSequenceMD5","fetchSizeLimit","getSubAdapter","seqConf","sequenceAdapter","dataAdapter","configure","catch","e","getHeader","_opts","getHeaderText","seqId","end","refName","refIdToOriginalName","sequence","firstValueFrom","getFeatures","assemblyName","pipe","toArray","sort","a","b","chunk","chunkStart","chunkEnd","trimStart","Math","max","trimLength","min","toLocaleString","setupPre","opts","statusCallback","updateStatus","async","conf","getSamHeader","idToName","nameToId","l","tag","forEach","sqLine","refId","item","value","rgLine","_rgLine$data$find","find","setup","getRefNames","refNameToId","indexOf","_this$samHeader$idToN","_this$seqIdToRefName","region","signal","filterBy","originalRefName","ObservableCreate","console","warn","observer","complete","records","getRecordsForRange","checkAbortSignal","flagInclude","flagExclude","tagFilter","_this$samHeader$readG","v","next","cramRecordToFeature","freeResources","getMultiRegionFeatureDensityStats","regions","bytes","bytesForRegions","Promise","all","chrId","getEntriesForRange","sliceBytes","flat","reduce"],"sourceRoot":""}