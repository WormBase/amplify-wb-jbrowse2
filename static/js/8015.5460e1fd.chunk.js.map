{"version":3,"file":"static/js/8015.5460e1fd.chunk.js","mappings":"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","sources":["../../../plugins/alignments/src/BamAdapter/BamSlightlyLazyFeature.ts","../../../plugins/alignments/src/BamAdapter/BamAdapter.ts","../../../plugins/alignments/src/HtsgetBamAdapter/HtsgetBamAdapter.ts"],"sourcesContent":["/* eslint-disable no-underscore-dangle */\nimport {\n  Feature,\n  SimpleFeatureSerialized,\n} from '@jbrowse/core/util/simpleFeature'\nimport { BamRecord } from '@gmod/bam'\n\n// locals\nimport { getClip, getMismatches } from '../MismatchParser'\nimport BamAdapter from './BamAdapter'\n\nexport default class BamSlightlyLazyFeature implements Feature {\n  // uses parameter properties to automatically create fields on the class\n  // https://www.typescriptlang.org/docs/handbook/classes.html#parameter-properties\n  constructor(\n    private record: BamRecord,\n    private adapter: BamAdapter,\n    private ref?: string,\n  ) {}\n\n  _get_name() {\n    return this.record.get('name')\n  }\n\n  _get_type(): string {\n    return 'match'\n  }\n\n  _get_score(): number {\n    return this.record.get('mq')\n  }\n\n  _get_flags(): string {\n    return this.record.flags\n  }\n\n  _get_strand(): number {\n    return this.record.isReverseComplemented() ? -1 : 1\n  }\n\n  _get_pair_orientation() {\n    return this.record.isPaired() ? this.record.getPairOrientation() : undefined\n  }\n\n  _get_next_ref() {\n    return this.record.isPaired()\n      ? this.adapter.refIdToName(this.record._next_refid())\n      : undefined\n  }\n\n  _get_next_pos() {\n    return this.record.isPaired() ? this.record._next_pos() : undefined\n  }\n\n  _get_next_segment_position() {\n    return this.record.isPaired()\n      ? `${this.adapter.refIdToName(this.record._next_refid())}:${\n          this.record._next_pos() + 1\n        }`\n      : undefined\n  }\n\n  _get_seq() {\n    return this.record.getReadBases()\n  }\n\n  qualRaw() {\n    return this.record.qualRaw()\n  }\n\n  set() {}\n\n  tags() {\n    const properties = Object.getOwnPropertyNames(\n      BamSlightlyLazyFeature.prototype,\n    )\n\n    return [\n      ...new Set(\n        properties\n          .filter(\n            prop =>\n              prop.startsWith('_get_') &&\n              prop !== '_get_mismatches' &&\n              prop !== '_get_tags',\n          )\n          .map(methodName => methodName.replace('_get_', ''))\n          .concat(this.record._tags()),\n      ),\n    ]\n  }\n\n  id() {\n    return `${this.adapter.id}-${this.record.id()}`\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  get(field: string): any {\n    const methodName = `_get_${field}`\n    // @ts-expect-error\n    if (this[methodName]) {\n      // @ts-expect-error\n      return this[methodName]()\n    }\n    return this.record.get(field)\n  }\n\n  _get_refName() {\n    return this.adapter.refIdToName(this.record.seq_id())\n  }\n\n  parent() {\n    return undefined\n  }\n\n  children() {\n    return undefined\n  }\n\n  pairedFeature() {\n    return false\n  }\n\n  toJSON(): SimpleFeatureSerialized {\n    return {\n      ...Object.fromEntries(\n        this.tags()\n          .map(t => [t, this.get(t)])\n          .filter(elt => elt[1] !== undefined),\n      ),\n      uniqueId: this.id(),\n    }\n  }\n\n  _get_mismatches() {\n    return getMismatches(\n      this.get('CIGAR'),\n      this.get('MD'),\n      this.get('seq'),\n      this.ref,\n      this.qualRaw(),\n    )\n  }\n\n  _get_clipPos() {\n    const cigar = this.get('CIGAR') || ''\n    return getClip(cigar, this.get('strand'))\n  }\n}\n","import { BamFile } from '@gmod/bam'\nimport {\n  BaseFeatureDataAdapter,\n  BaseOptions,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { Region } from '@jbrowse/core/util/types'\nimport { bytesForRegions, updateStatus, Feature } from '@jbrowse/core/util'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport { toArray } from 'rxjs/operators'\nimport { firstValueFrom } from 'rxjs'\n\n// locals\nimport BamSlightlyLazyFeature from './BamSlightlyLazyFeature'\nimport { IFilter } from '../shared'\n\ninterface Header {\n  idToName: string[]\n  nameToId: Record<string, number>\n}\n\nexport default class BamAdapter extends BaseFeatureDataAdapter {\n  private samHeader?: Header\n\n  private setupP?: Promise<Header>\n  private configureP?: Promise<{\n    bam: BamFile\n    sequenceAdapter?: BaseFeatureDataAdapter\n  }>\n\n  // derived classes may not use the same configuration so a custom\n  // configure method allows derived classes to override this behavior\n  protected async configurePre() {\n    const bamLocation = this.getConf('bamLocation')\n    const location = this.getConf(['index', 'location'])\n    const indexType = this.getConf(['index', 'indexType'])\n    const pm = this.pluginManager\n    const csi = indexType === 'CSI'\n    const bam = new BamFile({\n      bamFilehandle: openLocation(bamLocation, pm),\n      csiFilehandle: csi ? openLocation(location, pm) : undefined,\n      baiFilehandle: !csi ? openLocation(location, pm) : undefined,\n\n      // chunkSizeLimit and fetchSizeLimit are more troublesome than\n      // helpful, and have given overly large values on the ultra long\n      // nanopore reads even with 500MB limits, so disabled with infinity\n      yieldThreadTime: Infinity,\n    })\n\n    const adapterConfig = this.getConf('sequenceAdapter')\n    if (adapterConfig && this.getSubAdapter) {\n      const { dataAdapter } = await this.getSubAdapter(adapterConfig)\n      return {\n        bam,\n        sequenceAdapter: dataAdapter as BaseFeatureDataAdapter,\n      }\n    } else {\n      return { bam }\n    }\n  }\n\n  protected async configure() {\n    if (!this.configureP) {\n      this.configureP = this.configurePre().catch(e => {\n        this.configureP = undefined\n        throw e\n      })\n    }\n    return this.configureP\n  }\n\n  async getHeader(opts?: BaseOptions) {\n    const { bam } = await this.configure()\n    return bam.getHeaderText(opts)\n  }\n\n  private async setupPre(opts?: BaseOptions) {\n    const { statusCallback = () => {} } = opts || {}\n    const { bam } = await this.configure()\n    this.samHeader = await updateStatus(\n      'Downloading index',\n      statusCallback,\n      async () => {\n        const samHeader = await bam.getHeader(opts)\n\n        // use the @SQ lines in the header to figure out the\n        // mapping between ref ref ID numbers and names\n        const idToName: string[] = []\n        const nameToId: Record<string, number> = {}\n        samHeader\n          ?.filter(l => l.tag === 'SQ')\n          .forEach((sqLine, refId) => {\n            sqLine.data.forEach(item => {\n              if (item.tag === 'SN') {\n                // this is the ref name\n                const refName = item.value\n                nameToId[refName] = refId\n                idToName[refId] = refName\n              }\n            })\n          })\n\n        return { idToName, nameToId }\n      },\n    )\n    return this.samHeader\n  }\n\n  async setup(opts?: BaseOptions) {\n    if (!this.setupP) {\n      this.setupP = this.setupPre(opts).catch(e => {\n        this.setupP = undefined\n        throw e\n      })\n    }\n    return this.setupP\n  }\n\n  async getRefNames(opts?: BaseOptions) {\n    const { idToName } = await this.setup(opts)\n    return idToName\n  }\n\n  private async seqFetch(refName: string, start: number, end: number) {\n    const { sequenceAdapter } = await this.configure()\n    const refSeqStore = sequenceAdapter\n    if (!refSeqStore) {\n      return undefined\n    }\n    if (!refName) {\n      return undefined\n    }\n\n    const features = refSeqStore.getFeatures({\n      refName,\n      start,\n      end,\n      assemblyName: '',\n    })\n\n    const seqChunks = await firstValueFrom(features.pipe(toArray()))\n\n    let sequence = ''\n    seqChunks\n      .sort((a, b) => a.get('start') - b.get('start'))\n      .forEach(chunk => {\n        const chunkStart = chunk.get('start')\n        const chunkEnd = chunk.get('end')\n        const trimStart = Math.max(start - chunkStart, 0)\n        const trimEnd = Math.min(end - chunkStart, chunkEnd - chunkStart)\n        const trimLength = trimEnd - trimStart\n        const chunkSeq = chunk.get('seq') || chunk.get('residues')\n        sequence += chunkSeq.slice(trimStart, trimStart + trimLength)\n      })\n\n    if (sequence.length !== end - start) {\n      throw new Error(\n        `sequence fetch failed: fetching ${refName}:${(\n          start - 1\n        ).toLocaleString()}-${end.toLocaleString()} returned ${sequence.length.toLocaleString()} bases, but should have returned ${(\n          end - start\n        ).toLocaleString()}`,\n      )\n    }\n    return sequence\n  }\n\n  getFeatures(\n    region: Region & { originalRefName?: string },\n    opts?: BaseOptions & {\n      filterBy: IFilter\n    },\n  ) {\n    const { refName, start, end, originalRefName } = region\n    const { signal, filterBy, statusCallback = () => {} } = opts || {}\n    return ObservableCreate<Feature>(async observer => {\n      const { bam } = await this.configure()\n      await this.setup(opts)\n      const records = await updateStatus(\n        'Downloading alignments',\n        statusCallback,\n        () => bam.getRecordsForRange(refName, start, end, opts),\n      )\n\n      await updateStatus('Processing alignments', statusCallback, async () => {\n        const {\n          flagInclude = 0,\n          flagExclude = 0,\n          tagFilter,\n          readName,\n        } = filterBy || {}\n\n        for (const record of records) {\n          let ref: string | undefined\n          if (!record.get('MD')) {\n            ref = await this.seqFetch(\n              originalRefName || refName,\n              record.get('start'),\n              record.get('end'),\n            )\n          }\n\n          const flags = record.flags\n          if ((flags & flagInclude) !== flagInclude && !(flags & flagExclude)) {\n            continue\n          }\n\n          if (tagFilter) {\n            const v = record.get(tagFilter.tag)\n            if (!(v === '*' ? v !== undefined : `${v}` === tagFilter.value)) {\n              continue\n            }\n          }\n\n          if (readName && record.get('name') !== readName) {\n            continue\n          }\n\n          observer.next(new BamSlightlyLazyFeature(record, this, ref))\n        }\n        observer.complete()\n      })\n    }, signal)\n  }\n\n  async getMultiRegionFeatureDensityStats(\n    regions: Region[],\n    opts?: BaseOptions,\n  ) {\n    const { bam } = await this.configure()\n    // this is a method to avoid calling on htsget adapters\n    if (bam.index) {\n      const bytes = await bytesForRegions(regions, bam)\n      const fetchSizeLimit = this.getConf('fetchSizeLimit')\n      return { bytes, fetchSizeLimit }\n    } else {\n      return super.getMultiRegionFeatureDensityStats(regions, opts)\n    }\n  }\n\n  freeResources(/* { region } */): void {}\n\n  // depends on setup being called before the BAM constructor\n  refIdToName(refId: number) {\n    return this.samHeader?.idToName[refId]\n  }\n}\n","import { BamFile, HtsgetFile } from '@gmod/bam'\nimport { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport BamAdapter from '../BamAdapter/BamAdapter'\n\nexport default class HtsgetBamAdapter extends BamAdapter {\n  protected async configurePre() {\n    const htsgetBase = this.getConf('htsgetBase')\n    const htsgetTrackId = this.getConf('htsgetTrackId')\n    const bam = new HtsgetFile({\n      baseUrl: htsgetBase,\n      trackId: htsgetTrackId,\n    }) as unknown as BamFile\n\n    const adapterConfig = this.getConf('sequenceAdapter')\n    if (adapterConfig && this.getSubAdapter) {\n      const adapter = await this.getSubAdapter(adapterConfig)\n      return {\n        bam,\n        sequenceAdapter: adapter.dataAdapter as BaseFeatureDataAdapter,\n      }\n    }\n    return { bam }\n  }\n}\n"],"names":["BamSlightlyLazyFeature","constructor","record","adapter","ref","_get_name","this","get","_get_type","_get_score","_get_flags","flags","_get_strand","isReverseComplemented","_get_pair_orientation","isPaired","getPairOrientation","undefined","_get_next_ref","refIdToName","_next_refid","_get_next_pos","_next_pos","_get_next_segment_position","concat","_get_seq","getReadBases","qualRaw","set","tags","properties","Object","getOwnPropertyNames","prototype","Set","filter","prop","startsWith","map","methodName","replace","_tags","id","field","_get_refName","seq_id","parent","children","pairedFeature","toJSON","fromEntries","t","elt","uniqueId","_get_mismatches","getMismatches","_get_clipPos","cigar","getClip","BamAdapter","BaseFeatureDataAdapter","arguments","samHeader","setupP","configureP","configurePre","bamLocation","getConf","location","indexType","pm","pluginManager","csi","bam","BamFile","bamFilehandle","openLocation","csiFilehandle","baiFilehandle","yieldThreadTime","Infinity","adapterConfig","getSubAdapter","dataAdapter","sequenceAdapter","configure","catch","e","getHeader","opts","getHeaderText","setupPre","statusCallback","updateStatus","async","idToName","nameToId","l","tag","forEach","sqLine","refId","data","item","refName","value","setup","getRefNames","seqFetch","start","end","features","getFeatures","assemblyName","seqChunks","firstValueFrom","pipe","toArray","sequence","sort","a","b","chunk","chunkStart","chunkEnd","trimStart","Math","max","trimLength","min","chunkSeq","slice","length","Error","toLocaleString","region","originalRefName","signal","filterBy","ObservableCreate","records","getRecordsForRange","flagInclude","flagExclude","tagFilter","readName","v","observer","next","complete","getMultiRegionFeatureDensityStats","regions","index","bytes","bytesForRegions","fetchSizeLimit","super","freeResources","_this$samHeader","HtsgetBamAdapter","htsgetBase","htsgetTrackId","HtsgetFile","baseUrl","trackId"],"sourceRoot":""}