{"version":3,"file":"static/js/8022.b97462d7.chunk.js","mappings":"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","sources":["../../../node_modules/@gmod/tabix/src/util.ts","../../../node_modules/@gmod/tabix/src/virtualOffset.ts","../../../node_modules/@gmod/tabix/src/chunk.ts","../../../node_modules/@gmod/tabix/src/indexFile.ts","../../../node_modules/@gmod/tabix/src/tbi.ts","../../../node_modules/@gmod/tabix/src/csi.ts","../../../node_modules/@gmod/tabix/src/tabixIndexedFile.ts","../../../node_modules/abortable-promise-cache/esm/AbortablePromiseCache.js","../../../node_modules/abortable-promise-cache/esm/AggregateAbortController.js","../../../node_modules/abortable-promise-cache/esm/AggregateStatusReporter.js","../../../node_modules/abortable-promise-cache/esm/abortcontroller-ponyfill.js","../../../node_modules/abortable-promise-cache/esm/index.js"],"sourcesContent":["import Chunk from './chunk'\nimport VirtualOffset from './virtualOffset'\n\nexport function longToNumber(long: Long) {\n  if (\n    long.greaterThan(Number.MAX_SAFE_INTEGER) ||\n    long.lessThan(Number.MIN_SAFE_INTEGER)\n  ) {\n    throw new Error('integer overflow')\n  }\n  return long.toNumber()\n}\n\nclass AbortError extends Error {\n  public code: string | undefined\n}\n/**\n * Properly check if the given AbortSignal is aborted.\n * Per the standard, if the signal reads as aborted,\n * this function throws either a DOMException AbortError, or a regular error\n * with a `code` attribute set to `ERR_ABORTED`.\n *\n * For convenience, passing `undefined` is a no-op\n *\n * @param {AbortSignal} [signal] an AbortSignal, or anything with an `aborted` attribute\n * @returns nothing\n */\nexport function checkAbortSignal(signal?: AbortSignal) {\n  if (!signal) {\n    return\n  }\n\n  if (signal.aborted) {\n    if (typeof DOMException !== 'undefined') {\n      // eslint-disable-next-line  no-undef\n      throw new DOMException('aborted', 'AbortError')\n    } else {\n      const e = new AbortError('aborted')\n      e.code = 'ERR_ABORTED'\n      throw e\n    }\n  }\n}\n\n/**\n * Skips to the next tick, then runs `checkAbortSignal`.\n * Await this to inside an otherwise synchronous loop to\n * provide a place to break when an abort signal is received.\n * @param {AbortSignal} signal\n */\nexport async function abortBreakPoint(signal?: AbortSignal) {\n  await Promise.resolve()\n  checkAbortSignal(signal)\n}\n\nexport function canMergeBlocks(chunk1: Chunk, chunk2: Chunk) {\n  return (\n    chunk2.minv.blockPosition - chunk1.maxv.blockPosition < 65000 &&\n    chunk2.maxv.blockPosition - chunk1.minv.blockPosition < 5000000\n  )\n}\n\nexport function optimizeChunks(chunks: Chunk[], lowest: VirtualOffset) {\n  const mergedChunks: Chunk[] = []\n  let lastChunk: Chunk | null = null\n\n  if (chunks.length === 0) {\n    return chunks\n  }\n\n  chunks.sort(function (c0, c1) {\n    const dif = c0.minv.blockPosition - c1.minv.blockPosition\n    if (dif !== 0) {\n      return dif\n    } else {\n      return c0.minv.dataPosition - c1.minv.dataPosition\n    }\n  })\n\n  chunks.forEach(chunk => {\n    if (!lowest || chunk.maxv.compareTo(lowest) > 0) {\n      if (lastChunk === null) {\n        mergedChunks.push(chunk)\n        lastChunk = chunk\n      } else {\n        if (canMergeBlocks(lastChunk, chunk)) {\n          if (chunk.maxv.compareTo(lastChunk.maxv) > 0) {\n            lastChunk.maxv = chunk.maxv\n          }\n        } else {\n          mergedChunks.push(chunk)\n          lastChunk = chunk\n        }\n      }\n    }\n  })\n\n  return mergedChunks\n}\n","import { Buffer } from 'buffer'\nexport default class VirtualOffset {\n  public blockPosition: number\n  public dataPosition: number\n  constructor(blockPosition: number, dataPosition: number) {\n    this.blockPosition = blockPosition // < offset of the compressed data block\n    this.dataPosition = dataPosition // < offset into the uncompressed data\n  }\n\n  toString() {\n    return `${this.blockPosition}:${this.dataPosition}`\n  }\n\n  compareTo(b: VirtualOffset) {\n    return (\n      this.blockPosition - b.blockPosition || this.dataPosition - b.dataPosition\n    )\n  }\n\n  static min(...args: VirtualOffset[]) {\n    let min\n    let i = 0\n    for (; !min; i += 1) {\n      min = args[i]\n    }\n    for (; i < args.length; i += 1) {\n      if (min.compareTo(args[i]) > 0) {\n        min = args[i]\n      }\n    }\n    return min\n  }\n}\nexport function fromBytes(bytes: Buffer, offset = 0, bigendian = false) {\n  if (bigendian) {\n    throw new Error('big-endian virtual file offsets not implemented')\n  }\n\n  return new VirtualOffset(\n    bytes[offset + 7] * 0x10000000000 +\n      bytes[offset + 6] * 0x100000000 +\n      bytes[offset + 5] * 0x1000000 +\n      bytes[offset + 4] * 0x10000 +\n      bytes[offset + 3] * 0x100 +\n      bytes[offset + 2],\n    (bytes[offset + 1] << 8) | bytes[offset],\n  )\n}\n","import VirtualOffset from './virtualOffset'\n\n// little class representing a chunk in the index\nexport default class Chunk {\n  public minv: VirtualOffset\n  public maxv: VirtualOffset\n  public bin: number\n  public _fetchedSize?: number\n\n  /**\n   * @param {VirtualOffset} minv\n   * @param {VirtualOffset} maxv\n   * @param {number} bin\n   * @param {number} [fetchedSize]\n   */\n  constructor(\n    minv: VirtualOffset,\n    maxv: VirtualOffset,\n    bin: number,\n    fetchedSize = undefined,\n  ) {\n    this.minv = minv\n    this.maxv = maxv\n    this.bin = bin\n    this._fetchedSize = fetchedSize\n  }\n\n  toUniqueString() {\n    return `${this.minv}..${this.maxv} (bin ${\n      this.bin\n    }, fetchedSize ${this.fetchedSize()})`\n  }\n\n  toString() {\n    return this.toUniqueString()\n  }\n\n  compareTo(b: Chunk) {\n    return (\n      this.minv.compareTo(b.minv) ||\n      this.maxv.compareTo(b.maxv) ||\n      this.bin - b.bin\n    )\n  }\n\n  fetchedSize() {\n    if (this._fetchedSize !== undefined) {\n      return this._fetchedSize\n    }\n    return this.maxv.blockPosition + (1 << 16) - this.minv.blockPosition\n  }\n}\n","import { GenericFilehandle } from 'generic-filehandle'\nimport VirtualOffset from './virtualOffset'\nimport Chunk from './chunk'\n\nexport interface Options {\n  // support having some unknown parts of the options\n  [key: string]: unknown\n  signal?: AbortSignal\n}\n\nexport interface IndexData {\n  refNameToId: { [key: string]: number }\n  refIdToName: string[]\n  metaChar: string | null\n  columnNumbers: { ref: number; start: number; end: number }\n  coordinateType: string\n  format: string\n  [key: string]: any\n}\n\nexport default abstract class IndexFile {\n  public filehandle: GenericFilehandle\n  public renameRefSeq: (arg0: string) => string\n  private parseP?: Promise<IndexData>\n\n  constructor({\n    filehandle,\n    renameRefSeqs = (n: string) => n,\n  }: {\n    filehandle: GenericFilehandle\n    renameRefSeqs?: (a: string) => string\n  }) {\n    this.filehandle = filehandle\n    this.renameRefSeq = renameRefSeqs\n  }\n\n  public abstract lineCount(refName: string, args: Options): Promise<number>\n\n  protected abstract _parse(opts: Options): Promise<IndexData>\n\n  public async getMetadata(opts: Options = {}) {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const { indices, ...rest } = await this.parse(opts)\n    return rest\n  }\n\n  public abstract blocksForRange(\n    refName: string,\n    start: number,\n    end: number,\n    opts: Options,\n  ): Promise<Chunk[]>\n\n  _findFirstData(\n    currentFdl: VirtualOffset | undefined,\n    virtualOffset: VirtualOffset,\n  ) {\n    if (currentFdl) {\n      return currentFdl.compareTo(virtualOffset) > 0\n        ? virtualOffset\n        : currentFdl\n    } else {\n      return virtualOffset\n    }\n  }\n\n  async parse(opts: Options = {}) {\n    if (!this.parseP) {\n      this.parseP = this._parse(opts).catch(e => {\n        this.parseP = undefined\n        throw e\n      })\n    }\n    return this.parseP\n  }\n\n  async hasRefSeq(seqId: number, opts: Options = {}) {\n    return !!((await this.parse(opts)).indices[seqId] || {}).binIndex\n  }\n}\n","import Long from 'long'\nimport { Buffer } from 'buffer'\nimport VirtualOffset, { fromBytes } from './virtualOffset'\nimport Chunk from './chunk'\nimport { unzip } from '@gmod/bgzf-filehandle'\nimport { longToNumber, optimizeChunks, checkAbortSignal } from './util'\nimport IndexFile, { Options } from './indexFile'\n\nconst TBI_MAGIC = 21578324 // TBI\\1\nconst TAD_LIDX_SHIFT = 14\n\n/**\n * calculate the list of bins that may overlap with region [beg,end) (zero-based half-open)\n */\nfunction reg2bins(beg: number, end: number) {\n  beg += 1 // < convert to 1-based closed\n  end -= 1\n  return [\n    [0, 0],\n    [1 + (beg >> 26), 1 + (end >> 26)],\n    [9 + (beg >> 23), 9 + (end >> 23)],\n    [73 + (beg >> 20), 73 + (end >> 20)],\n    [585 + (beg >> 17), 585 + (end >> 17)],\n    [4681 + (beg >> 14), 4681 + (end >> 14)],\n  ]\n}\n\nexport default class TabixIndex extends IndexFile {\n  async lineCount(refName: string, opts: Options = {}) {\n    const indexData = await this.parse(opts)\n    if (!indexData) {\n      return -1\n    }\n    const refId = indexData.refNameToId[refName]\n    const idx = indexData.indices[refId]\n    if (!idx) {\n      return -1\n    }\n    const { stats } = indexData.indices[refId]\n    if (stats) {\n      return stats.lineCount\n    }\n    return -1\n  }\n\n  // fetch and parse the index\n  async _parse(opts: Options = {}) {\n    const buf = await this.filehandle.readFile(opts)\n    const bytes = await unzip(buf)\n    checkAbortSignal(opts.signal)\n\n    // check TBI magic numbers\n    if (bytes.readUInt32LE(0) !== TBI_MAGIC /* \"TBI\\1\" */) {\n      throw new Error('Not a TBI file')\n      // TODO: do we need to support big-endian TBI files?\n    }\n\n    // number of reference sequences in the index\n    const refCount = bytes.readInt32LE(4)\n    const formatFlags = bytes.readInt32LE(8)\n    const coordinateType =\n      formatFlags & 0x10000 ? 'zero-based-half-open' : '1-based-closed'\n    const formatOpts: { [key: number]: string } = {\n      0: 'generic',\n      1: 'SAM',\n      2: 'VCF',\n    }\n    const format = formatOpts[formatFlags & 0xf]\n    if (!format) {\n      throw new Error(`invalid Tabix preset format flags ${formatFlags}`)\n    }\n    const columnNumbers = {\n      ref: bytes.readInt32LE(12),\n      start: bytes.readInt32LE(16),\n      end: bytes.readInt32LE(20),\n    }\n    const metaValue = bytes.readInt32LE(24)\n    const depth = 5\n    const maxBinNumber = ((1 << ((depth + 1) * 3)) - 1) / 7\n    const maxRefLength = 2 ** (14 + depth * 3)\n    const metaChar = metaValue ? String.fromCharCode(metaValue) : null\n    const skipLines = bytes.readInt32LE(28)\n\n    // read sequence dictionary\n    const nameSectionLength = bytes.readInt32LE(32)\n    const { refNameToId, refIdToName } = this._parseNameBytes(\n      bytes.slice(36, 36 + nameSectionLength),\n    )\n\n    // read the indexes for each reference sequence\n    let currOffset = 36 + nameSectionLength\n    let firstDataLine: VirtualOffset | undefined\n    const indices = new Array(refCount).fill(0).map(() => {\n      // the binning index\n      const binCount = bytes.readInt32LE(currOffset)\n      currOffset += 4\n      const binIndex: { [key: number]: Chunk[] } = {}\n      let stats\n      for (let j = 0; j < binCount; j += 1) {\n        const bin = bytes.readUInt32LE(currOffset)\n        currOffset += 4\n        if (bin > maxBinNumber + 1) {\n          throw new Error(\n            'tabix index contains too many bins, please use a CSI index',\n          )\n        } else if (bin === maxBinNumber + 1) {\n          const chunkCount = bytes.readInt32LE(currOffset)\n          currOffset += 4\n          if (chunkCount === 2) {\n            stats = this.parsePseudoBin(bytes, currOffset)\n          }\n          currOffset += 16 * chunkCount\n        } else {\n          const chunkCount = bytes.readInt32LE(currOffset)\n          currOffset += 4\n          const chunks = new Array(chunkCount)\n          for (let k = 0; k < chunkCount; k += 1) {\n            const u = fromBytes(bytes, currOffset)\n            const v = fromBytes(bytes, currOffset + 8)\n            currOffset += 16\n            firstDataLine = this._findFirstData(firstDataLine, u)\n            chunks[k] = new Chunk(u, v, bin)\n          }\n          binIndex[bin] = chunks\n        }\n      }\n\n      // the linear index\n      const linearCount = bytes.readInt32LE(currOffset)\n      currOffset += 4\n      const linearIndex = new Array(linearCount)\n      for (let k = 0; k < linearCount; k += 1) {\n        linearIndex[k] = fromBytes(bytes, currOffset)\n        currOffset += 8\n        firstDataLine = this._findFirstData(firstDataLine, linearIndex[k])\n      }\n      return { binIndex, linearIndex, stats }\n    })\n\n    return {\n      indices,\n      metaChar,\n      maxBinNumber,\n      maxRefLength,\n      skipLines,\n      firstDataLine,\n      columnNumbers,\n      coordinateType,\n      format,\n      refIdToName,\n      refNameToId,\n      maxBlockSize: 1 << 16,\n    }\n  }\n\n  parsePseudoBin(bytes: Buffer, offset: number) {\n    const lineCount = longToNumber(\n      Long.fromBytesLE(\n        bytes.slice(offset + 16, offset + 24) as unknown as number[],\n        true,\n      ),\n    )\n    return { lineCount }\n  }\n\n  _parseNameBytes(namesBytes: Buffer) {\n    let currRefId = 0\n    let currNameStart = 0\n    const refIdToName: string[] = []\n    const refNameToId: { [key: string]: number } = {}\n    for (let i = 0; i < namesBytes.length; i += 1) {\n      if (!namesBytes[i]) {\n        if (currNameStart < i) {\n          let refName = namesBytes.toString('utf8', currNameStart, i)\n          refName = this.renameRefSeq(refName)\n          refIdToName[currRefId] = refName\n          refNameToId[refName] = currRefId\n        }\n        currNameStart = i + 1\n        currRefId += 1\n      }\n    }\n    return { refNameToId, refIdToName }\n  }\n\n  async blocksForRange(\n    refName: string,\n    min: number,\n    max: number,\n    opts: Options = {},\n  ) {\n    if (min < 0) {\n      min = 0\n    }\n\n    const indexData = await this.parse(opts)\n    if (!indexData) {\n      return []\n    }\n    const refId = indexData.refNameToId[refName]\n    const ba = indexData.indices[refId]\n    if (!ba) {\n      return []\n    }\n\n    const minOffset = ba.linearIndex.length\n      ? ba.linearIndex[\n          min >> TAD_LIDX_SHIFT >= ba.linearIndex.length\n            ? ba.linearIndex.length - 1\n            : min >> TAD_LIDX_SHIFT\n        ]\n      : new VirtualOffset(0, 0)\n    if (!minOffset) {\n      console.warn('querying outside of possible tabix range')\n    }\n\n    // const { linearIndex, binIndex } = indexes\n\n    const overlappingBins = reg2bins(min, max) // List of bin #s that overlap min, max\n    const chunks: Chunk[] = []\n\n    // Find chunks in overlapping bins.  Leaf bins (< 4681) are not pruned\n    for (const [start, end] of overlappingBins) {\n      for (let bin = start; bin <= end; bin++) {\n        if (ba.binIndex[bin]) {\n          const binChunks = ba.binIndex[bin]\n          for (let c = 0; c < binChunks.length; ++c) {\n            chunks.push(new Chunk(binChunks[c].minv, binChunks[c].maxv, bin))\n          }\n        }\n      }\n    }\n\n    // Use the linear index to find minimum file position of chunks that could\n    // contain alignments in the region\n    const nintv = ba.linearIndex.length\n    let lowest = null\n    const minLin = Math.min(min >> 14, nintv - 1)\n    const maxLin = Math.min(max >> 14, nintv - 1)\n    for (let i = minLin; i <= maxLin; ++i) {\n      const vp = ba.linearIndex[i]\n      if (vp) {\n        if (!lowest || vp.compareTo(lowest) < 0) {\n          lowest = vp\n        }\n      }\n    }\n\n    return optimizeChunks(chunks, lowest)\n  }\n}\n","import Long from 'long'\nimport { Buffer } from 'buffer'\nimport { unzip } from '@gmod/bgzf-filehandle'\n\nimport VirtualOffset, { fromBytes } from './virtualOffset'\nimport Chunk from './chunk'\nimport { longToNumber, optimizeChunks } from './util'\n\nimport IndexFile, { Options } from './indexFile'\n\nconst CSI1_MAGIC = 21582659 // CSI\\1\nconst CSI2_MAGIC = 38359875 // CSI\\2\n\nfunction lshift(num: number, bits: number) {\n  return num * 2 ** bits\n}\nfunction rshift(num: number, bits: number) {\n  return Math.floor(num / 2 ** bits)\n}\n\nexport default class CSI extends IndexFile {\n  private maxBinNumber: number\n  private depth: number\n  private minShift: number\n  constructor(args: any) {\n    super(args)\n    this.maxBinNumber = 0\n    this.depth = 0\n    this.minShift = 0\n  }\n  async lineCount(refName: string, opts: Options = {}): Promise<number> {\n    const indexData = await this.parse(opts)\n    if (!indexData) {\n      return -1\n    }\n    const refId = indexData.refNameToId[refName]\n    const idx = indexData.indices[refId]\n    if (!idx) {\n      return -1\n    }\n    const { stats } = indexData.indices[refId]\n    if (stats) {\n      return stats.lineCount\n    }\n    return -1\n  }\n  async indexCov() {\n    throw new Error('CSI indexes do not support indexcov')\n  }\n\n  parseAuxData(bytes: Buffer, offset: number) {\n    const formatFlags = bytes.readInt32LE(offset)\n    const coordinateType =\n      formatFlags & 0x10000 ? 'zero-based-half-open' : '1-based-closed'\n    const format = { 0: 'generic', 1: 'SAM', 2: 'VCF' }[formatFlags & 0xf]\n    if (!format) {\n      throw new Error(`invalid Tabix preset format flags ${formatFlags}`)\n    }\n    const columnNumbers = {\n      ref: bytes.readInt32LE(offset + 4),\n      start: bytes.readInt32LE(offset + 8),\n      end: bytes.readInt32LE(offset + 12),\n    }\n    const metaValue = bytes.readInt32LE(offset + 16)\n    const metaChar = metaValue ? String.fromCharCode(metaValue) : null\n    const skipLines = bytes.readInt32LE(offset + 20)\n    const nameSectionLength = bytes.readInt32LE(offset + 24)\n\n    const { refIdToName, refNameToId } = this._parseNameBytes(\n      bytes.slice(offset + 28, offset + 28 + nameSectionLength),\n    )\n\n    return {\n      refIdToName,\n      refNameToId,\n      skipLines,\n      metaChar,\n      columnNumbers,\n      format,\n      coordinateType,\n    }\n  }\n\n  _parseNameBytes(namesBytes: Buffer) {\n    let currRefId = 0\n    let currNameStart = 0\n    const refIdToName = []\n    const refNameToId: { [key: string]: number } = {}\n    for (let i = 0; i < namesBytes.length; i += 1) {\n      if (!namesBytes[i]) {\n        if (currNameStart < i) {\n          let refName = namesBytes.toString('utf8', currNameStart, i)\n          refName = this.renameRefSeq(refName)\n          refIdToName[currRefId] = refName\n          refNameToId[refName] = currRefId\n        }\n        currNameStart = i + 1\n        currRefId += 1\n      }\n    }\n    return { refNameToId, refIdToName }\n  }\n\n  // fetch and parse the index\n\n  async _parse(opts: Options = {}) {\n    const bytes = await unzip((await this.filehandle.readFile(opts)) as Buffer)\n\n    // check TBI magic numbers\n    let csiVersion\n    if (bytes.readUInt32LE(0) === CSI1_MAGIC) {\n      csiVersion = 1\n    } else if (bytes.readUInt32LE(0) === CSI2_MAGIC) {\n      csiVersion = 2\n    } else {\n      throw new Error('Not a CSI file')\n      // TODO: do we need to support big-endian CSI files?\n    }\n\n    this.minShift = bytes.readInt32LE(4)\n    this.depth = bytes.readInt32LE(8)\n    this.maxBinNumber = ((1 << ((this.depth + 1) * 3)) - 1) / 7\n    const maxRefLength = 2 ** (this.minShift + this.depth * 3)\n    const auxLength = bytes.readInt32LE(12)\n    const aux =\n      auxLength && auxLength >= 30\n        ? this.parseAuxData(bytes, 16)\n        : {\n            refIdToName: [],\n            refNameToId: {},\n            metaChar: null,\n            columnNumbers: { ref: 0, start: 1, end: 2 },\n            coordinateType: 'zero-based-half-open',\n            format: 'generic',\n          }\n    const refCount = bytes.readInt32LE(16 + auxLength)\n\n    // read the indexes for each reference sequence\n    let firstDataLine: VirtualOffset | undefined\n    let currOffset = 16 + auxLength + 4\n    const indices = new Array(refCount).fill(0).map(() => {\n      // the binning index\n      const binCount = bytes.readInt32LE(currOffset)\n      currOffset += 4\n      const binIndex: { [key: string]: Chunk[] } = {}\n      let stats // < provided by parsing a pseudo-bin, if present\n      for (let j = 0; j < binCount; j += 1) {\n        const bin = bytes.readUInt32LE(currOffset)\n        if (bin > this.maxBinNumber) {\n          // this is a fake bin that actually has stats information\n          // about the reference sequence in it\n          stats = this.parsePseudoBin(bytes, currOffset + 4)\n          currOffset += 4 + 8 + 4 + 16 + 16\n        } else {\n          const loffset = fromBytes(bytes, currOffset + 4)\n          firstDataLine = this._findFirstData(firstDataLine, loffset)\n          const chunkCount = bytes.readInt32LE(currOffset + 12)\n          currOffset += 16\n          const chunks = new Array(chunkCount)\n          for (let k = 0; k < chunkCount; k += 1) {\n            const u = fromBytes(bytes, currOffset)\n            const v = fromBytes(bytes, currOffset + 8)\n            currOffset += 16\n            // this._findFirstData(data, u)\n            chunks[k] = new Chunk(u, v, bin)\n          }\n          binIndex[bin] = chunks\n        }\n      }\n\n      return { binIndex, stats }\n    })\n\n    return {\n      ...aux,\n      csi: true,\n      refCount,\n      maxBlockSize: 1 << 16,\n      firstDataLine,\n      csiVersion,\n      indices,\n      depth: this.depth,\n      maxBinNumber: this.maxBinNumber,\n      maxRefLength,\n    }\n  }\n\n  parsePseudoBin(bytes: Buffer, offset: number) {\n    const lineCount = longToNumber(\n      Long.fromBytesLE(\n        bytes.slice(offset + 28, offset + 36) as unknown as number[],\n        true,\n      ),\n    )\n    return { lineCount }\n  }\n\n  async blocksForRange(\n    refName: string,\n    min: number,\n    max: number,\n    opts: Options = {},\n  ) {\n    if (min < 0) {\n      min = 0\n    }\n\n    const indexData = await this.parse(opts)\n    if (!indexData) {\n      return []\n    }\n    const refId = indexData.refNameToId[refName]\n    const ba = indexData.indices[refId]\n    if (!ba) {\n      return []\n    }\n\n    // const { linearIndex, binIndex } = indexes\n\n    const overlappingBins = this.reg2bins(min, max) // List of bin #s that overlap min, max\n    const chunks: Chunk[] = []\n\n    // Find chunks in overlapping bins.  Leaf bins (< 4681) are not pruned\n    for (const [start, end] of overlappingBins) {\n      for (let bin = start; bin <= end; bin++) {\n        if (ba.binIndex[bin]) {\n          const binChunks = ba.binIndex[bin]\n          for (let c = 0; c < binChunks.length; ++c) {\n            chunks.push(new Chunk(binChunks[c].minv, binChunks[c].maxv, bin))\n          }\n        }\n      }\n    }\n\n    return optimizeChunks(chunks, new VirtualOffset(0, 0))\n  }\n\n  /**\n   * calculate the list of bins that may overlap with region [beg,end) (zero-based half-open)\n   */\n  reg2bins(beg: number, end: number) {\n    beg -= 1 // < convert to 1-based closed\n    if (beg < 1) {\n      beg = 1\n    }\n    if (end > 2 ** 50) {\n      end = 2 ** 34\n    } // 17 GiB ought to be enough for anybody\n    end -= 1\n    let l = 0\n    let t = 0\n    let s = this.minShift + this.depth * 3\n    const bins = []\n    for (; l <= this.depth; s -= 3, t += lshift(1, l * 3), l += 1) {\n      const b = t + rshift(beg, s)\n      const e = t + rshift(end, s)\n      if (e - b + bins.length > this.maxBinNumber) {\n        throw new Error(\n          `query ${beg}-${end} is too large for current binning scheme (shift ${this.minShift}, depth ${this.depth}), try a smaller query or a coarser index binning scheme`,\n        )\n      }\n      bins.push([b, e])\n    }\n    return bins\n  }\n}\n","import AbortablePromiseCache from 'abortable-promise-cache'\nimport LRU from 'quick-lru'\nimport { Buffer } from 'buffer'\nimport { GenericFilehandle, LocalFile } from 'generic-filehandle'\nimport { unzip, unzipChunkSlice } from '@gmod/bgzf-filehandle'\nimport { checkAbortSignal } from './util'\nimport IndexFile, { Options, IndexData } from './indexFile'\n\nimport Chunk from './chunk'\nimport TBI from './tbi'\nimport CSI from './csi'\n\ntype GetLinesCallback = (line: string, fileOffset: number) => void\n\nconst decoder =\n  typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-8') : undefined\n\ninterface GetLinesOpts {\n  [key: string]: unknown\n  signal?: AbortSignal\n  lineCallback: GetLinesCallback\n}\n\ninterface ReadChunk {\n  buffer: Buffer\n  cpositions: number[]\n  dpositions: number[]\n}\n\nfunction timeout(time: number) {\n  return new Promise(resolve => setTimeout(resolve, time))\n}\nexport default class TabixIndexedFile {\n  private filehandle: GenericFilehandle\n  private index: IndexFile\n  private chunkSizeLimit: number\n  private yieldTime: number\n  private renameRefSeq: (n: string) => string\n  private chunkCache: AbortablePromiseCache<Chunk, ReadChunk>\n\n  /**\n   * @param {object} args\n   * @param {string} [args.path]\n   * @param {filehandle} [args.filehandle]\n   * @param {string} [args.tbiPath]\n   * @param {filehandle} [args.tbiFilehandle]\n   * @param {string} [args.csiPath]\n   * @param {filehandle} [args.csiFilehandle]\n   * @param {number} [args.yieldTime] yield to main thread after N milliseconds if reading features is taking a long time to avoid hanging main thread\n   * @param {function} [args.renameRefSeqs] optional function with sig `string => string` to transform\n   * reference sequence names for the purpose of indexing and querying. note that the data that is returned is\n   * not altered, just the names of the reference sequences that are used for querying.\n   */\n  constructor({\n    path,\n    filehandle,\n    tbiPath,\n    tbiFilehandle,\n    csiPath,\n    csiFilehandle,\n    yieldTime = 500,\n    chunkSizeLimit = 50000000,\n    renameRefSeqs = n => n,\n    chunkCacheSize = 5 * 2 ** 20,\n  }: {\n    path?: string\n    filehandle?: GenericFilehandle\n    tbiPath?: string\n    tbiFilehandle?: GenericFilehandle\n    csiPath?: string\n    csiFilehandle?: GenericFilehandle\n    yieldTime?: number\n    chunkSizeLimit?: number\n    renameRefSeqs?: (n: string) => string\n    chunkCacheSize?: number\n  }) {\n    if (filehandle) {\n      this.filehandle = filehandle\n    } else if (path) {\n      this.filehandle = new LocalFile(path)\n    } else {\n      throw new TypeError('must provide either filehandle or path')\n    }\n\n    if (tbiFilehandle) {\n      this.index = new TBI({\n        filehandle: tbiFilehandle,\n        renameRefSeqs,\n      })\n    } else if (csiFilehandle) {\n      this.index = new CSI({\n        filehandle: csiFilehandle,\n        renameRefSeqs,\n      })\n    } else if (tbiPath) {\n      this.index = new TBI({\n        filehandle: new LocalFile(tbiPath),\n        renameRefSeqs,\n      })\n    } else if (csiPath) {\n      this.index = new CSI({\n        filehandle: new LocalFile(csiPath),\n        renameRefSeqs,\n      })\n    } else if (path) {\n      this.index = new TBI({\n        filehandle: new LocalFile(`${path}.tbi`),\n        renameRefSeqs,\n      })\n    } else {\n      throw new TypeError(\n        'must provide one of tbiFilehandle, tbiPath, csiFilehandle, or csiPath',\n      )\n    }\n\n    this.chunkSizeLimit = chunkSizeLimit\n    this.renameRefSeq = renameRefSeqs\n    this.yieldTime = yieldTime\n    this.chunkCache = new AbortablePromiseCache<Chunk, ReadChunk>({\n      cache: new LRU({ maxSize: Math.floor(chunkCacheSize / (1 << 16)) }),\n      fill: (args: Chunk, signal?: AbortSignal) =>\n        this.readChunk(args, { signal }),\n    })\n  }\n\n  /**\n   * @param refName name of the reference sequence\n   * @param start start of the region (in 0-based half-open coordinates)\n   * @param end end of the region (in 0-based half-open coordinates)\n   * @param opts callback called for each line in the region. can also pass a object param containing obj.lineCallback, obj.signal, etc\n   * @returns promise that is resolved when the whole read is finished, rejected on error\n   */\n  async getLines(\n    refName: string,\n    start: number,\n    end: number,\n    opts: GetLinesOpts | GetLinesCallback,\n  ) {\n    let signal: AbortSignal | undefined\n    let options: Options = {}\n    let callback: (line: string, lineOffset: number) => void\n    if (typeof opts === 'undefined') {\n      throw new TypeError('line callback must be provided')\n    }\n    if (typeof opts === 'function') {\n      callback = opts\n    } else {\n      options = opts\n      callback = opts.lineCallback\n    }\n    if (refName === undefined) {\n      throw new TypeError('must provide a reference sequence name')\n    }\n    if (!callback) {\n      throw new TypeError('line callback must be provided')\n    }\n\n    const metadata = await this.index.getMetadata(options)\n    checkAbortSignal(signal)\n    if (!start) {\n      start = 0\n    }\n    if (!end) {\n      end = metadata.maxRefLength\n    }\n    if (!(start <= end)) {\n      throw new TypeError(\n        'invalid start and end coordinates. start must be less than or equal to end',\n      )\n    }\n    if (start === end) {\n      return\n    }\n\n    const chunks = await this.index.blocksForRange(refName, start, end, options)\n    checkAbortSignal(signal)\n\n    // check the chunks for any that are over the size limit.  if\n    // any are, don't fetch any of them\n    for (let i = 0; i < chunks.length; i += 1) {\n      const size = chunks[i].fetchedSize()\n      if (size > this.chunkSizeLimit) {\n        throw new Error(\n          `Too much data. Chunk size ${size.toLocaleString()} bytes exceeds chunkSizeLimit of ${this.chunkSizeLimit.toLocaleString()}.`,\n        )\n      }\n    }\n\n    // now go through each chunk and parse and filter the lines out of it\n    let last = Date.now()\n    for (let chunkNum = 0; chunkNum < chunks.length; chunkNum += 1) {\n      let previousStartCoordinate: number | undefined\n      const c = chunks[chunkNum]\n      const { buffer, cpositions, dpositions } = await this.chunkCache.get(\n        c.toString(),\n        c,\n      )\n\n      checkAbortSignal(signal)\n      let blockStart = 0\n      let pos = 0\n      while (blockStart < buffer.length) {\n        const n = buffer.indexOf('\\n', blockStart)\n        if (n === -1) {\n          break\n        }\n        const b = buffer.slice(blockStart, n)\n        const line = decoder?.decode(b) || b.toString()\n\n        if (dpositions) {\n          while (blockStart + c.minv.dataPosition >= dpositions[pos++]) {}\n          pos--\n        }\n\n        // filter the line for whether it is within the requested range\n        const { startCoordinate, overlaps } = this.checkLine(\n          metadata,\n          refName,\n          start,\n          end,\n          line,\n        )\n\n        // do a small check just to make sure that the lines are really sorted\n        // by start coordinate\n        if (\n          previousStartCoordinate !== undefined &&\n          startCoordinate !== undefined &&\n          previousStartCoordinate > startCoordinate\n        ) {\n          throw new Error(\n            `Lines not sorted by start coordinate (${previousStartCoordinate} > ${startCoordinate}), this file is not usable with Tabix.`,\n          )\n        }\n        previousStartCoordinate = startCoordinate\n\n        if (overlaps) {\n          callback(\n            line.trim(),\n            // cpositions[pos] refers to actual file offset of a bgzip block boundaries\n            //\n            // we multiply by (1 <<8) in order to make sure each block has a \"unique\"\n            // address space so that data in that block could never overlap\n            //\n            // then the blockStart-dpositions is an uncompressed file offset from\n            // that bgzip block boundary, and since the cpositions are multiplied by\n            // (1 << 8) these uncompressed offsets get a unique space\n            cpositions[pos] * (1 << 8) +\n              (blockStart - dpositions[pos]) +\n              c.minv.dataPosition +\n              1,\n          )\n        } else if (startCoordinate !== undefined && startCoordinate >= end) {\n          // the lines were overlapping the region, but now have stopped, so\n          // we must be at the end of the relevant data and we can stop\n          // processing data now\n          return\n        }\n\n        // yield if we have emitted beyond the yield limit\n        if (this.yieldTime && last - Date.now() > this.yieldTime) {\n          last = Date.now()\n          checkAbortSignal(signal)\n          await timeout(1)\n        }\n        blockStart = n + 1\n      }\n    }\n  }\n\n  async getMetadata(opts: Options = {}) {\n    return this.index.getMetadata(opts)\n  }\n\n  /**\n   * get a buffer containing the \"header\" region of\n   * the file, which are the bytes up to the first\n   * non-meta line\n   */\n  async getHeaderBuffer(opts: Options = {}) {\n    const { firstDataLine, metaChar, maxBlockSize } = await this.getMetadata(\n      opts,\n    )\n    checkAbortSignal(opts.signal)\n    const maxFetch = (firstDataLine?.blockPosition || 0) + maxBlockSize\n    // TODO: what if we don't have a firstDataLine, and the header\n    // actually takes up more than one block? this case is not covered here\n\n    let bytes = await this._readRegion(0, maxFetch, opts)\n    checkAbortSignal(opts.signal)\n    try {\n      bytes = await unzip(bytes)\n    } catch (e) {\n      console.error(e)\n      throw new Error(\n        //@ts-ignore\n        `error decompressing block ${e.code} at 0 (length ${maxFetch}) ${e}`,\n      )\n    }\n\n    // trim off lines after the last non-meta line\n    if (metaChar) {\n      // trim backward from the end\n      let lastNewline = -1\n      const newlineByte = '\\n'.charCodeAt(0)\n      const metaByte = metaChar.charCodeAt(0)\n      for (let i = 0; i < bytes.length; i += 1) {\n        if (i === lastNewline + 1 && bytes[i] !== metaByte) {\n          break\n        }\n        if (bytes[i] === newlineByte) {\n          lastNewline = i\n        }\n      }\n      bytes = bytes.slice(0, lastNewline + 1)\n    }\n    return bytes\n  }\n\n  /**\n   * get a string containing the \"header\" region of the\n   * file, is the portion up to the first non-meta line\n   *\n   * @returns {Promise} for a string\n   */\n  async getHeader(opts: Options = {}) {\n    const bytes = await this.getHeaderBuffer(opts)\n    return bytes.toString('utf8')\n  }\n\n  /**\n   * get an array of reference sequence names, in the order in which\n   * they occur in the file. reference sequence renaming is not applied\n   * to these names.\n   */\n  async getReferenceSequenceNames(opts: Options = {}) {\n    const metadata = await this.getMetadata(opts)\n    return metadata.refIdToName\n  }\n\n  /**\n   * @param {object} metadata metadata object from the parsed index,\n   * containing columnNumbers, metaChar, and format\n   * @param {string} regionRefName\n   * @param {number} regionStart region start coordinate (0-based-half-open)\n   * @param {number} regionEnd region end coordinate (0-based-half-open)\n   * @param {array[string]} line\n   * @returns {object} like `{startCoordinate, overlaps}`. overlaps is boolean,\n   * true if line is a data line that overlaps the given region\n   */\n  checkLine(\n    metadata: IndexData,\n    regionRefName: string,\n    regionStart: number,\n    regionEnd: number,\n    line: string,\n  ) {\n    const { columnNumbers, metaChar, coordinateType, format } = metadata\n    // skip meta lines\n    if (line.charAt(0) === metaChar) {\n      return { overlaps: false }\n    }\n\n    // check ref/start/end using column metadata from index\n    let { ref, start, end } = columnNumbers\n    if (!ref) {\n      ref = 0\n    }\n    if (!start) {\n      start = 0\n    }\n    if (!end) {\n      end = 0\n    }\n    if (format === 'VCF') {\n      end = 8\n    }\n    const maxColumn = Math.max(ref, start, end)\n\n    // this code is kind of complex, but it is fairly fast.\n    // basically, we want to avoid doing a split, because if the lines are really long\n    // that could lead to us allocating a bunch of extra memory, which is slow\n\n    let currentColumnNumber = 1 // cols are numbered starting at 1 in the index metadata\n    let currentColumnStart = 0\n    let refSeq = ''\n    let startCoordinate = -Infinity\n    for (let i = 0; i < line.length + 1; i += 1) {\n      if (line[i] === '\\t' || i === line.length) {\n        if (currentColumnNumber === ref) {\n          if (\n            this.renameRefSeq(line.slice(currentColumnStart, i)) !==\n            regionRefName\n          ) {\n            return { overlaps: false }\n          }\n        } else if (currentColumnNumber === start) {\n          startCoordinate = parseInt(line.slice(currentColumnStart, i), 10)\n          // we convert to 0-based-half-open\n          if (coordinateType === '1-based-closed') {\n            startCoordinate -= 1\n          }\n          if (startCoordinate >= regionEnd) {\n            return { startCoordinate, overlaps: false }\n          }\n          if (end === 0 || end === start) {\n            // if we have no end, we assume the feature is 1 bp long\n            if (startCoordinate + 1 <= regionStart) {\n              return { startCoordinate, overlaps: false }\n            }\n          }\n        } else if (format === 'VCF' && currentColumnNumber === 4) {\n          refSeq = line.slice(currentColumnStart, i)\n        } else if (currentColumnNumber === end) {\n          let endCoordinate\n          // this will never match if there is no end column\n          if (format === 'VCF') {\n            endCoordinate = this._getVcfEnd(\n              startCoordinate,\n              refSeq,\n              line.slice(currentColumnStart, i),\n            )\n          } else {\n            endCoordinate = parseInt(line.slice(currentColumnStart, i), 10)\n          }\n          if (endCoordinate <= regionStart) {\n            return { overlaps: false }\n          }\n        }\n        currentColumnStart = i + 1\n        currentColumnNumber += 1\n        if (currentColumnNumber > maxColumn) {\n          break\n        }\n      }\n    }\n    return { startCoordinate, overlaps: true }\n  }\n\n  _getVcfEnd(startCoordinate: number, refSeq: string, info: any) {\n    let endCoordinate = startCoordinate + refSeq.length\n    // ignore TRA features as they specify CHR2 and END\n    // as being on a different chromosome\n    // if CHR2 is on the same chromosome, still ignore it\n    // because there should be another pairwise feature\n    // at the end of this one\n    const isTRA = info.indexOf('SVTYPE=TRA') !== -1\n    if (info[0] !== '.' && !isTRA) {\n      let prevChar = ';'\n      for (let j = 0; j < info.length; j += 1) {\n        if (prevChar === ';' && info.slice(j, j + 4) === 'END=') {\n          let valueEnd = info.indexOf(';', j)\n          if (valueEnd === -1) {\n            valueEnd = info.length\n          }\n          endCoordinate = parseInt(info.slice(j + 4, valueEnd), 10)\n          break\n        }\n        prevChar = info[j]\n      }\n    } else if (isTRA) {\n      return startCoordinate + 1\n    }\n    return endCoordinate\n  }\n\n  /**\n   * return the approximate number of data lines in the given reference sequence\n   * @param refSeq reference sequence name\n   * @returns number of data lines present on that reference sequence\n   */\n  async lineCount(refName: string, opts: Options = {}) {\n    return this.index.lineCount(refName, opts)\n  }\n\n  async _readRegion(pos: number, size: number, opts: Options = {}) {\n    const b = Buffer.alloc(size)\n    const { bytesRead, buffer } = await this.filehandle.read(\n      b,\n      0,\n      size,\n      pos,\n      opts,\n    )\n\n    return buffer.slice(0, bytesRead)\n  }\n\n  /**\n   * read and uncompress the data in a chunk (composed of one or more\n   * contiguous bgzip blocks) of the file\n   */\n  async readChunk(c: Chunk, opts: Options = {}) {\n    // fetch the uncompressed data, uncompress carefully a block at a time,\n    // and stop when done\n\n    const data = await this._readRegion(\n      c.minv.blockPosition,\n      c.fetchedSize(),\n      opts,\n    )\n    try {\n      return unzipChunkSlice(data, c)\n    } catch (e) {\n      throw new Error(`error decompressing c ${c.toString()} ${e}`)\n    }\n  }\n}\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst abortcontroller_ponyfill_1 = require(\"./abortcontroller-ponyfill\");\nconst AggregateAbortController_1 = __importDefault(require(\"./AggregateAbortController\"));\nconst AggregateStatusReporter_1 = __importDefault(require(\"./AggregateStatusReporter\"));\nclass AbortablePromiseCache {\n    constructor({ fill, cache, }) {\n        if (typeof fill !== 'function') {\n            throw new TypeError('must pass a fill function');\n        }\n        if (typeof cache !== 'object') {\n            throw new TypeError('must pass a cache object');\n        }\n        if (typeof cache.get !== 'function' ||\n            typeof cache.set !== 'function' ||\n            typeof cache.delete !== 'function') {\n            throw new TypeError('cache must implement get(key), set(key, val), and and delete(key)');\n        }\n        this.cache = cache;\n        this.fillCallback = fill;\n    }\n    static isAbortException(exception) {\n        return (\n        // DOMException\n        exception.name === 'AbortError' ||\n            // standard-ish non-DOM abort exception\n            //@ts-ignore\n            exception.code === 'ERR_ABORTED' ||\n            // stringified DOMException\n            exception.message === 'AbortError: aborted' ||\n            // stringified standard-ish exception\n            exception.message === 'Error: aborted');\n    }\n    evict(key, entry) {\n        if (this.cache.get(key) === entry) {\n            this.cache.delete(key);\n        }\n    }\n    fill(key, data, signal, statusCallback) {\n        const aborter = new AggregateAbortController_1.default();\n        const statusReporter = new AggregateStatusReporter_1.default();\n        statusReporter.addCallback(statusCallback);\n        const newEntry = {\n            aborter: aborter,\n            promise: this.fillCallback(data, aborter.signal, (message) => {\n                statusReporter.callback(message);\n            }),\n            settled: false,\n            statusReporter,\n            get aborted() {\n                return this.aborter.signal.aborted;\n            },\n        };\n        newEntry.aborter.addSignal(signal);\n        // remove the fill from the cache when its abortcontroller fires, if still in there\n        newEntry.aborter.signal.addEventListener('abort', () => {\n            if (!newEntry.settled) {\n                this.evict(key, newEntry);\n            }\n        });\n        // chain off the cached promise to record when it settles\n        newEntry.promise\n            .then(() => {\n            newEntry.settled = true;\n        }, () => {\n            newEntry.settled = true;\n            // if the fill throws an error (including abort) and is still in the cache, remove it\n            this.evict(key, newEntry);\n        })\n            .catch(e => {\n            // this will only be reached if there is some kind of\n            // bad bug in this library\n            console.error(e);\n            throw e;\n        });\n        this.cache.set(key, newEntry);\n    }\n    static checkSinglePromise(promise, signal) {\n        // check just this signal for having been aborted, and abort the\n        // promise if it was, regardless of what happened with the cached\n        // response\n        function checkForSingleAbort() {\n            if (signal && signal.aborted) {\n                throw Object.assign(new Error('aborted'), { code: 'ERR_ABORTED' });\n            }\n        }\n        return promise.then(result => {\n            checkForSingleAbort();\n            return result;\n        }, error => {\n            checkForSingleAbort();\n            throw error;\n        });\n    }\n    has(key) {\n        return this.cache.has(key);\n    }\n    /**\n     * Callback for getting status of the pending async\n     *\n     * @callback statusCallback\n     * @param {any} status, current status string or message object\n     */\n    /**\n     * @param {any} key cache key to use for this request\n     * @param {any} data data passed as the first argument to the fill callback\n     * @param {AbortSignal} [signal] optional AbortSignal object that aborts the request\n     * @param {statusCallback} a callback to get the current status of a pending async operation\n     */\n    get(key, data, signal, statusCallback) {\n        if (!signal && data instanceof abortcontroller_ponyfill_1.AbortSignal) {\n            throw new TypeError('second get argument appears to be an AbortSignal, perhaps you meant to pass `null` for the fill data?');\n        }\n        const cacheEntry = this.cache.get(key);\n        if (cacheEntry) {\n            if (cacheEntry.aborted && !cacheEntry.settled) {\n                // if it's aborted but has not realized it yet, evict it and redispatch\n                this.evict(key, cacheEntry);\n                return this.get(key, data, signal, statusCallback);\n            }\n            if (cacheEntry.settled) {\n                // too late to abort, just return it\n                return cacheEntry.promise;\n            }\n            // request is in-flight, add this signal to its list of signals,\n            // or if there is no signal, the aborter will become non-abortable\n            cacheEntry.aborter.addSignal(signal);\n            cacheEntry.statusReporter.addCallback(statusCallback);\n            return AbortablePromiseCache.checkSinglePromise(cacheEntry.promise, signal);\n        }\n        // if we got here, it is not in the cache. fill.\n        this.fill(key, data, signal, statusCallback);\n        return AbortablePromiseCache.checkSinglePromise(\n        //see https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#non-null-assertion-operator-postfix-\n        //eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        this.cache.get(key).promise, signal);\n    }\n    /**\n     * delete the given entry from the cache. if it exists and its fill request has\n     * not yet settled, the fill will be signaled to abort.\n     *\n     * @param {any} key\n     */\n    delete(key) {\n        const cachedEntry = this.cache.get(key);\n        if (cachedEntry) {\n            if (!cachedEntry.settled) {\n                cachedEntry.aborter.abort();\n            }\n            this.cache.delete(key);\n        }\n    }\n    /**\n     * Clear all requests from the cache. Aborts any that have not settled.\n     * @returns {number} count of entries deleted\n     */\n    clear() {\n        // iterate without needing regenerator-runtime\n        const keyIter = this.cache.keys();\n        let deleteCount = 0;\n        for (let result = keyIter.next(); !result.done; result = keyIter.next()) {\n            this.delete(result.value);\n            deleteCount += 1;\n        }\n        return deleteCount;\n    }\n}\nexports.default = AbortablePromiseCache;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst abortcontroller_ponyfill_1 = require(\"./abortcontroller-ponyfill\");\nclass NullSignal {\n}\n/**\n * aggregates a number of abort signals, will only fire the aggregated\n * abort if all of the input signals have been aborted\n */\nclass AggregateAbortController {\n    constructor() {\n        this.signals = new Set();\n        this.abortController = new abortcontroller_ponyfill_1.AbortController();\n    }\n    /**\n     * @param {AbortSignal} [signal] optional AbortSignal to add. if falsy,\n     *  will be treated as a null-signal, and this abortcontroller will no\n     *  longer be abortable.\n     */\n    //@ts-ignore\n    addSignal(signal = new NullSignal()) {\n        if (this.signal.aborted) {\n            throw new Error('cannot add a signal, already aborted!');\n        }\n        // note that a NullSignal will never fire, so if we\n        // have one this thing will never actually abort\n        this.signals.add(signal);\n        if (signal.aborted) {\n            // handle the abort immediately if it is already aborted\n            // for some reason\n            this.handleAborted(signal);\n        }\n        else if (typeof signal.addEventListener === 'function') {\n            signal.addEventListener('abort', () => {\n                this.handleAborted(signal);\n            });\n        }\n    }\n    handleAborted(signal) {\n        this.signals.delete(signal);\n        if (this.signals.size === 0) {\n            this.abortController.abort();\n        }\n    }\n    get signal() {\n        return this.abortController.signal;\n    }\n    abort() {\n        this.abortController.abort();\n    }\n}\nexports.default = AggregateAbortController;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass AggregateStatusReporter {\n    constructor() {\n        this.callbacks = new Set();\n    }\n    addCallback(callback = () => { }) {\n        this.callbacks.add(callback);\n        callback(this.currentMessage);\n    }\n    callback(message) {\n        this.currentMessage = message;\n        this.callbacks.forEach(elt => {\n            elt(message);\n        });\n    }\n}\nexports.default = AggregateStatusReporter;\n","\"use strict\";\n/* eslint-disable */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AbortSignal = exports.AbortController = void 0;\nconst cjs_ponyfill_1 = require(\"abortcontroller-polyfill/dist/cjs-ponyfill\");\nvar getGlobal = function () {\n    // the only reliable means to get the global object is\n    // `Function('return this')()`\n    // However, this causes CSP violations in Chrome apps.\n    if (typeof self !== 'undefined') {\n        return self;\n    }\n    if (typeof window !== 'undefined') {\n        return window;\n    }\n    if (typeof global !== 'undefined') {\n        return global;\n    }\n    throw new Error('unable to locate global object');\n};\n//@ts-ignore\nlet AbortController = typeof getGlobal().AbortController === 'undefined' ? cjs_ponyfill_1.AbortController : getGlobal().AbortController;\nexports.AbortController = AbortController;\n//@ts-ignore\nlet AbortSignal = typeof getGlobal().AbortController === 'undefined' ? cjs_ponyfill_1.AbortSignal : getGlobal().AbortSignal;\nexports.AbortSignal = AbortSignal;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst AbortablePromiseCache_1 = __importDefault(require(\"./AbortablePromiseCache\"));\nexports.default = AbortablePromiseCache_1.default;\n"],"names":["longToNumber","long","greaterThan","Number","MAX_SAFE_INTEGER","lessThan","MIN_SAFE_INTEGER","Error","toNumber","AbortError","_Error","_inherits","_super","_createSuper","_classCallCheck","apply","arguments","_createClass","_wrapNativeSuper","checkAbortSignal","signal","aborted","DOMException","e","code","optimizeChunks","chunks","lowest","mergedChunks","lastChunk","length","sort","c0","c1","dif","minv","blockPosition","dataPosition","forEach","chunk","chunk1","chunk2","maxv","compareTo","push","VirtualOffset","this","key","value","concat","b","min","i","_len","args","Array","_key","fromBytes","bytes","offset","undefined","Chunk","bin","fetchedSize","_fetchedSize","toUniqueString","IndexFile","_getMetadata","_parse","_hasRefSeq","_ref","filehandle","_ref$renameRefSeqs","renameRefSeqs","n","renameRefSeq","_asyncToGenerator","_regeneratorRuntime","mark","_callee","opts","_yield$this$parse","rest","_args","wrap","_context","prev","next","parse","sent","indices","_objectWithoutProperties","_excluded","abrupt","stop","currentFdl","virtualOffset","_callee2","_this","_args2","_context2","parseP","catch","_x","_callee3","seqId","_args3","_context3","t1","t0","binIndex","reg2bins","beg","end","TabixIndex","_IndexFile","_lineCount","_parse2","_blocksForRange","refName","indexData","refId","stats","refNameToId","lineCount","buf","refCount","formatFlags","coordinateType","format","columnNumbers","metaValue","maxBinNumber","maxRefLength","metaChar","skipLines","nameSectionLength","_this$_parseNameBytes","refIdToName","currOffset","firstDataLine","readFile","unzip","readUInt32LE","readInt32LE","ref","start","Math","pow","String","fromCharCode","_parseNameBytes","slice","fill","map","binCount","j","chunkCount","parsePseudoBin","k","u","v","_findFirstData","linearCount","linearIndex","maxBlockSize","Long","namesBytes","currRefId","currNameStart","toString","_x2","_x3","_x4","max","ba","overlappingBins","_iterator","_step","_step$value","binChunks","c","nintv","minLin","maxLin","vp","console","warn","_createForOfIteratorHelper","s","done","_slicedToArray","err","f","rshift","num","bits","floor","CSI","_indexCov","call","depth","minShift","csiVersion","auxLength","aux","_this2","parseAuxData","loffset","_objectSpread","csi","_callee4","_args4","_context4","l","t","bins","decoder","TextDecoder","timeout","time","Promise","resolve","setTimeout","TabixIndexedFile","_getLines","_getHeaderBuffer","_getHeader","_getReferenceSequenceNames","_readRegion2","_readChunk","path","tbiPath","tbiFilehandle","csiPath","csiFilehandle","_ref$yieldTime","yieldTime","_ref$chunkSizeLimit","chunkSizeLimit","_ref$chunkCacheSize","chunkCacheSize","TypeError","LocalFile","index","TBI","chunkCache","AbortablePromiseCache","cache","LRU","maxSize","readChunk","options","callback","metadata","size","last","chunkNum","previousStartCoordinate","_yield$this$chunkCach","buffer","cpositions","dpositions","blockStart","pos","line","_this$checkLine","startCoordinate","overlaps","lineCallback","getMetadata","blocksForRange","toLocaleString","Date","now","get","indexOf","decode","checkLine","trim","_yield$this$getMetada","maxFetch","lastNewline","newlineByte","metaByte","_readRegion","error","charCodeAt","getHeaderBuffer","_callee5","_args5","_context5","regionRefName","regionStart","regionEnd","charAt","maxColumn","currentColumnNumber","currentColumnStart","refSeq","Infinity","parseInt","_getVcfEnd","info","endCoordinate","isTRA","prevChar","valueEnd","_x5","_callee6","_args6","_context6","_x6","_x7","_callee7","_yield$this$filehandl","bytesRead","_args7","_context7","Buffer","alloc","read","_x8","_callee8","data","_args8","_context8","unzipChunkSlice","require","__importDefault","mod","__esModule","Object","defineProperty","exports","abortcontroller_ponyfill_1","AggregateAbortController_1","AggregateStatusReporter_1","set","delete","fillCallback","entry","statusCallback","aborter","default","statusReporter","addCallback","newEntry","promise","message","settled","addSignal","addEventListener","evict","then","has","AbortSignal","cacheEntry","checkSinglePromise","cachedEntry","abort","keyIter","keys","deleteCount","result","exception","name","checkForSingleAbort","assign","NullSignal","AggregateAbortController","signals","Set","abortController","AbortController","add","handleAborted","AggregateStatusReporter","callbacks","currentMessage","elt","cjs_ponyfill_1","getGlobal","self","window","global","AbortablePromiseCache_1"],"sourceRoot":""}