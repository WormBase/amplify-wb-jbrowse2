{"version":3,"file":"static/js/4864.6ed44de3.chunk.js","mappings":"wOAkBe,MAAMA,UAAmBC,EAAAA,uBAY5BC,cAGN,CAAC,EAEL,oBAA6B,CAAC,cAAe,eAE7C,eAAcC,CAAUC,EAAoB,CAAC,GAC3C,MAAMC,EAAKC,KAAKC,cACVC,EAASF,KAAKG,QAAQ,eACtBC,QAAeC,EAAAA,EAAAA,qBAAmBC,EAAAA,EAAAA,cAAaJ,EAAQH,GAAKD,GAElE,GAAIM,EAAOG,OAAS,UAClB,MAAM,IAAIC,MAAM,8CAElB,MACMC,EADO,IAAIC,YAAY,OAAQ,CAAEC,OAAO,IAAQC,OAAOR,GAC1CS,MAAM,cAAcC,QAAOC,KAAOA,IAC/CC,EAAc,GACpB,IAAIC,EAAI,EACR,KAAOA,EAAIR,EAAMF,QAAUE,EAAMQ,GAAIC,WAAW,KAAMD,IACpDD,EAAYG,KAAKV,EAAMQ,IAEzB,MAAMG,EAASJ,EAAYK,KAAK,MAC1BC,EAAW,CAAC,EAClB,KAAOL,EAAIR,EAAMF,OAAQU,IAAK,CAC5B,MAAMM,EAAOd,EAAMQ,GACbO,EAAMD,EAAKE,QAAQ,MACnBC,EAAUH,EAAKI,MAAM,EAAGH,GACzBF,EAASI,KACZJ,EAASI,GAAW,IAEtBJ,EAASI,GAASP,KAAKI,EACzB,CAEA,MAAMK,EAAU5B,KAAKG,QAAQ,WAQ7B,MAAO,CACLiB,SACAE,WACAO,OAVa,IAAIC,EAAAA,EAAI,CAAEF,YAWvBG,YAVkB/B,KAAKG,QAAQ,eAW/B6B,YAVkBhC,KAAKG,QAAQ,eAW/B8B,OAVajC,KAAKG,QAAQ,UAW1B+B,SAVelC,KAAKG,QAAQ,YAW5BgC,OAVanC,KAAKG,QAAQ,UAY9B,CAEA,cAAMiC,CAAStC,EAAoB,CAAC,GAQlC,OAPKE,KAAKqC,cACRrC,KAAKqC,YAAcrC,KAAKH,UAAUC,GAAMwC,OAAOC,IAE7C,MADAvC,KAAKqC,iBAAcG,EACbD,CAAC,KAIJvC,KAAKqC,WACd,CAEA,iBAAaI,CAAY3C,EAAoB,CAAC,GAC5C,MAAM,SAAEwB,SAAmBtB,KAAKoC,SAAStC,GACzC,OAAO4C,OAAOC,KAAKrB,EACrB,CAEA,eAAMsB,CAAU9C,EAAoB,CAAC,GACnC,MAAM,OAAEsB,SAAiBpB,KAAKoC,SAAStC,GACvC,OAAOsB,CACT,CAEA,cAAMyB,GACJ,MAAM,OAAEzB,EAAM,YAAEW,SAAsB/B,KAAKoC,WAC3C,GAAIL,EAAYxB,OACd,OAAOwB,EAET,MACMe,EADO1B,EAAOP,MAAM,cAAcC,QAAOC,KAAOA,IACjCgC,IAAI,GACzB,OAAOD,GAASE,SAAS,MACrBF,EACGnB,MAAM,GACNd,MAAM,MACNoC,KAAIC,GAASA,EAAMC,cACtBX,CACN,CAEA,mCAAcY,CAA8B1B,GAC1C,MAAM,OAAEO,EAAM,SAAEC,EAAQ,OAAEC,EAAM,SAAEb,EAAQ,OAAEO,EAAM,YAAEG,SAC5ChC,KAAKoC,WACP3B,EAAQa,EAASI,GACvB,IAAKjB,EACH,OAEF,MAAM4C,QAAcrD,KAAK6C,WAEnBS,EAAe,IAAIC,EAAAA,GACzB,IAAK,IAAItC,EAAI,EAAGA,EAAIR,EAAMF,OAAQU,IAAK,CACrC,MAAMM,EAAOd,EAAMQ,GACbuC,EAAW,GAAGxD,KAAKyD,MAAM/B,KAAWT,IACpCyC,EAAO,IAAIC,EAAAA,eACfC,EAAAA,EAAAA,IAAY,CACVrC,OACAU,SACAC,WACAC,SACAH,cACAH,SACA2B,WACAH,WAGJC,EAAaO,OAAO,CAACH,EAAKI,IAAI,SAAUJ,EAAKI,IAAI,QAASJ,EAC5D,CAEA,OAAOJ,CACT,CAEA,6BAAMS,CAAwBrC,GAS5B,OARK1B,KAAKJ,cAAc8B,KACtB1B,KAAKJ,cAAc8B,GAAW1B,KAAKoD,8BACjC1B,GACAY,OAAOC,IAEP,MADAvC,KAAKJ,cAAc8B,QAAWc,EACxBD,CAAC,KAGJvC,KAAKJ,cAAc8B,EAC5B,CAEOsC,WAAAA,CAAYC,EAAenE,EAAoB,CAAC,GACrD,OAAOoE,EAAAA,EAAAA,mBAA0BC,UAC/B,MAAM,MAAEC,EAAK,IAAEC,EAAG,QAAE3C,GAAYuC,EAC1BX,QAAqBtD,KAAK+D,wBAAwBrC,GACxD4B,GAAcgB,OAAO,CAACF,EAAOC,IAAME,SAAQxD,IACzCyD,EAASC,KAAK1D,EAAE,IAElByD,EAASE,UAAU,GAClB5E,EAAK6E,UACV,CAEOC,aAAAA,GAAuB,E,kBC9KzB,SAASC,EAA+BC,GAC7C,MAAMC,EAAMD,GAAM3B,OAAOtC,MAAM,KAC/B,MAAO,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,GAAGmE,OAAMC,QACjBzC,IAAbuC,IAAME,KAAoBC,OAAOC,OAAOJ,EAAIE,KAEhD,CAEA,SAASG,EAA2BC,GAClC,GAAIR,EAA+BQ,GAAc,CAC/C,MACEC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,GACEf,EAAYlC,OAAOtC,MAAM,KAC7B,MAAO,CACLyE,cACAC,cACAC,cACAC,cACAC,YACAC,cACAC,YACAC,kBACAC,cACAC,uBACAC,wBACAC,wBACAC,sBACAC,4BACAC,YAEJ,CACA,MAAO,CAAEf,cACX,CC4CO,SAASzB,GAAY,KAC1BrC,EAAI,OACJU,EAAM,SACNC,EAAQ,OACRC,EAAM,YACNH,EAAW,OACXH,EAAM,SACN2B,EAAQ,MACRH,IAWA,MAAMgD,EAAY9E,EAAKV,MAAM,MAK7B,OAAOyF,EAAa,CAClB/E,OACAG,QANc2E,EAAUpE,GAOxBmC,OANaiC,EAAUnE,GAOvBmC,KANWgC,EAAUlE,IAAYD,IAAaC,EAAS,EAAI,GAO3DN,SACA2B,WACAxB,cACAqB,SAEJ,CAEO,SAASiD,GAAa,KAC3B/E,EAAI,QACJG,EAAO,MACP0C,EAAK,IACLC,EAAG,OACHxC,EAAM,SACN2B,EAAQ,YACRxB,EAAW,MACXqB,IAWA,MAAMgD,EAAY9E,EAAKV,MAAM,MACvB0F,EAAOlD,EAxHf,SAAuBmD,EAAkBjF,GACvC,MAAMkF,EAAM/D,OAAOgE,YACjBnF,EAAKV,MAAM,MAAMoC,KAAI,CAAClC,EAAGE,IAAM,CAACuF,EAAOvF,GAAKF,OAExC,YACJ4F,EAAW,WACXC,EAAU,YACVC,EAAW,SACXC,EAAQ,WACRC,EAAU,WACVC,KACGC,GACDR,EAEJ,MAAO,IACFQ,EACHN,YAAaO,EAASP,GACtBE,YAAaK,EAASL,GACtBG,WAAYE,EAASF,GACrBD,WAAYA,GAAcA,OAAavE,EACvCsE,SAAUA,GAAYA,OAAWtE,EACjCoE,WAAYA,GAAcA,OAAapE,EAE3C,CAkGM2E,CAAc9D,EAAO9B,GACrBM,EAAOuF,UAAU7F,EAAM,CAAEiC,cAE3B6D,OAAQC,EACRC,MAAOC,EACPC,MAAOC,EACPC,WAAYC,EACZC,SAAUC,KACPb,GACDV,GAEE,YACJM,EAAW,WACXG,EAAU,YACVL,EAAW,KACXoB,EAAI,WACJnB,EAAU,WACVG,EAAU,SACVD,EAAQ,YACRzB,KACG2C,GACDf,EACEM,EAAQvF,GAAeuE,EAAKvE,GAAewF,GAAUA,OAAShF,EAC9D6E,EAA4B,iBAAZC,EAzJZ,QADYvG,EA0JsCuG,IAxJlD,EACO,MAANvG,EACF,EAEA,EAoJ8DuG,EA1JzE,IAAwBvG,EA4JtB,MAAMkH,EAzHD,UAAoB,MACzB7D,EAAK,SACLZ,EAAQ,QACR9B,EAAO,YACPmF,EAAW,WACXD,EAAU,WACVI,EAAU,YACVL,IAUA,GAAIC,EAAY,CACd,MAAMqB,EAAc,GACdC,EAASrB,GAAeF,GAAe,GAC7C,IAAK,IAAIwB,EAAI,EAAGA,EAAIvB,EAAYuB,IAAK,CACnC,MAAMC,GAAQF,EAAOC,IAAM,GAAK/D,EAC1BiE,EAAQrB,IAAamB,GAC3B,GAAIE,GAASA,EAAQ,EAAG,CACtB,MAAMC,EAAOF,EAAOC,EACpBJ,EAAY9G,KAAK,CACfqC,SAAU,GAAGA,KAAY2E,IACzB/D,MAAOgE,EACP/D,IAAKiE,EACL5G,UACAqG,KAAM,SAEV,CACF,CACA,OAAOE,CACT,CACA,MAAO,EACT,CAoFsBM,CAAW,CAC7BnE,QACAZ,WACA9B,UACAmF,cACAD,aACAI,aACAL,gBAGF,OCrLK,UAA4B,UACjCN,EAAS,MACTjC,EAAK,IACLC,IAMA,QAASgC,EAAU,IAAM,KAAOjC,KAAWiC,EAAU,IAAM,KAAOhC,CACpE,CD2KMmE,CAAmB,CAAEnC,YAAWjC,QAAOC,QC1KtC,UAAkC,KACvC9C,EAAI,SACJiC,EAAQ,QACR9B,EAAO,MACP0C,EAAK,IACLC,IAUA,MAAO,CAAD,EAIJoE,EAAK,CAELpB,EAAO,CAAD,CAGNqB,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,GACE5H,EAAKV,MAAM,MAEf,MAAO,CACL2C,WACA9B,UACA0C,QACAC,MACAoE,OACAlB,OAAQqB,GAAsB,EAC9BvB,SACAqB,QACAU,OAAQX,EACRE,cACAC,oBACAC,QACAC,cACAC,cACAC,WACAC,SACAC,SACAC,WAEJ,CDmHWE,CAAyB,CAC9B9H,OACAiC,WACA9B,UACA0C,QACAC,QAEOQ,EAA+BQ,GD9IrC,UAAqC,SAC1C7B,EAAQ,QACR9B,EAAO,MACP0C,EAAK,IACLC,EAAG,YACHgB,KACG4B,IASH,MAAO,IACFA,KACA7B,EAA2BC,GAC9B7B,WACA9B,UACA0C,QACAC,MAEJ,CCwHWiF,CAA4B,IAC9BtB,EACHxE,WACA6B,cACA0C,OACAR,QACAnD,QACAC,MACAgD,SACA3F,UACAuG,gBEtMC,UAA0B,WAC/BlB,EAAU,WACVH,EAAU,OACVS,IAMA,OAAON,GAAcH,GAAyB,IAAXS,CACrC,CF8LakC,CAAiB,CAAElC,SAAQT,aAAYG,eE5L7C,SAAgCR,GACrC,MAAM,OACJc,EAAS,EACTI,MAAOC,EACPC,WAAYC,EACZC,SAAUC,EAAE,YACZjB,EAAW,YACXF,EAAW,WACXK,EAAU,SACVxD,KACGyD,GACDV,GAEF0B,YAAauB,EAAc,WAC3BzC,EAAU,SACVD,EAAQ,WACRF,EAAU,QACVlF,KACGsG,GACDf,EAEEgB,EAAgC,GAChCwB,EAAQD,EACX1I,QAAO4I,GAAwB,UAAfA,EAAM3B,OACtB4B,MAAK,CAACC,EAAGzB,IAAMyB,EAAExF,MAAQ+D,EAAE/D,QAE9B,IAAK,MAAMyF,KAASJ,EAAO,CACzB,MAAMrF,EAAQyF,EAAMzF,MACdC,EAAMwF,EAAMxF,IACd0C,GAAc1C,EAEhB4D,EAAY9G,KAAK,CACf4G,MAASV,EAAS,EAAI,OAAS,SAAzB,aACNjD,QACAC,MACA3C,YAEOqF,EAAa3C,GAAS2C,EAAa1C,GAAOyC,GAAYzC,EAE/D4D,EAAY9G,KACV,CACE4G,MAASV,EAAS,EAAI,OAAS,SAAzB,aACNjD,QACAC,IAAK0C,EACLrF,WAEF,CACEqG,KAAM,MACN3D,MAAO2C,EACP1C,MACA3C,YAGKqF,GAAc3C,GAAS0C,GAAYzC,EAE5C4D,EAAY9G,KAAK,CACf4G,KAAM,MACN3D,QACAC,MACA3C,YAEOqF,EAAa3C,GAAS2C,EAAa1C,GAAOyC,EAAWzC,EAE9D4D,EAAY9G,KACV,CACE4G,MAASV,EAAS,EAAI,OAAS,SAAzB,aACNjD,QACAC,IAAK0C,EACLrF,WAEF,CACEqG,KAAM,MACN3D,MAAO2C,EACP1C,IAAKyC,EACLpF,WAEF,CACEqG,MAASV,EAAS,EAAI,QAAU,QAA1B,aACNjD,MAAO0C,EACPzC,MACA3C,YAGKqF,GAAc3C,GAAS0C,EAAW1C,GAAS0C,EAAWzC,EAE/D4D,EAAY9G,KACV,CACE4G,KAAM,MACN3D,QACAC,IAAKyC,EACLpF,WAEF,CACEqG,MAASV,EAAS,EAAI,QAAU,QAA1B,aACNjD,MAAO0C,EACPzC,MACA3C,YAGKoF,GAAY1C,GAErB6D,EAAY9G,KAAK,CACf4G,MAASV,EAAS,EAAI,QAAU,QAA1B,aACNjD,QACAC,MACA3C,WAGN,CAEA,MAAO,IACFsG,EACHxE,WACA6D,SACAU,KAAM,OACNrG,UACAuG,cAEJ,CFuEW6B,CAAuB,IACzB7C,EACH5B,cACAwB,cACAE,aACAD,WACAE,aACAJ,aACAmB,OACAR,QACAnD,QACAC,MACAgD,SACA3F,UACA8B,WACAyE,gBAGK,IACFhB,EACHzD,WACA6B,cACA0C,OACAR,QACAnD,QACAC,MACAgD,SACA3F,UACAuG,cAGN,CAEO,SAASf,EAASnG,GACvB,YAAayB,IAANzB,EACU,iBAANA,EACLA,EAAEF,MAAM,KAAKoC,KAAIlC,IAAMA,IACvBA,OACFyB,CACN,C","sources":["../../../plugins/bed/src/BedAdapter/BedAdapter.ts","../../../plugins/bed/src/generateRepeatMaskerFeature.ts","../../../plugins/bed/src/util.ts","../../../plugins/bed/src/generateBedMethylFeature.ts","../../../plugins/bed/src/generateUcscTranscript.ts"],"sourcesContent":["import BED from '@gmod/bed'\nimport {\n  BaseFeatureDataAdapter,\n  BaseOptions,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport {\n  Region,\n  Feature,\n  fetchAndMaybeUnzip,\n  SimpleFeature,\n} from '@jbrowse/core/util'\nimport IntervalTree from '@flatten-js/interval-tree'\n\n// locals\nimport { featureData } from '../util'\n\nexport default class BedAdapter extends BaseFeatureDataAdapter {\n  protected bedFeatures?: Promise<{\n    header: string\n    features: Record<string, string[]>\n    parser: BED\n    columnNames: string[]\n    scoreColumn: string\n    colRef: number\n    colStart: number\n    colEnd: number\n  }>\n\n  protected intervalTrees: Record<\n    string,\n    Promise<IntervalTree | undefined> | undefined\n  > = {}\n\n  public static capabilities = ['getFeatures', 'getRefNames']\n\n  private async loadDataP(opts: BaseOptions = {}) {\n    const pm = this.pluginManager\n    const bedLoc = this.getConf('bedLocation')\n    const buffer = await fetchAndMaybeUnzip(openLocation(bedLoc, pm), opts)\n    // 512MB  max chrome string length is 512MB\n    if (buffer.length > 536_870_888) {\n      throw new Error('Data exceeds maximum string length (512MB)')\n    }\n    const data = new TextDecoder('utf8', { fatal: true }).decode(buffer)\n    const lines = data.split(/\\n|\\r\\n|\\r/).filter(f => !!f)\n    const headerLines = []\n    let i = 0\n    for (; i < lines.length && lines[i]!.startsWith('#'); i++) {\n      headerLines.push(lines[i])\n    }\n    const header = headerLines.join('\\n')\n    const features = {} as Record<string, string[]>\n    for (; i < lines.length; i++) {\n      const line = lines[i]!\n      const tab = line.indexOf('\\t')\n      const refName = line.slice(0, tab)\n      if (!features[refName]) {\n        features[refName] = []\n      }\n      features[refName].push(line)\n    }\n\n    const autoSql = this.getConf('autoSql') as string\n    const parser = new BED({ autoSql })\n    const columnNames = this.getConf('columnNames')\n    const scoreColumn = this.getConf('scoreColumn')\n    const colRef = this.getConf('colRef')\n    const colStart = this.getConf('colStart')\n    const colEnd = this.getConf('colEnd')\n\n    return {\n      header,\n      features,\n      parser,\n      columnNames,\n      scoreColumn,\n      colRef,\n      colStart,\n      colEnd,\n    }\n  }\n\n  async loadData(opts: BaseOptions = {}) {\n    if (!this.bedFeatures) {\n      this.bedFeatures = this.loadDataP(opts).catch((e: unknown) => {\n        this.bedFeatures = undefined\n        throw e\n      })\n    }\n\n    return this.bedFeatures\n  }\n\n  public async getRefNames(opts: BaseOptions = {}) {\n    const { features } = await this.loadData(opts)\n    return Object.keys(features)\n  }\n\n  async getHeader(opts: BaseOptions = {}) {\n    const { header } = await this.loadData(opts)\n    return header\n  }\n\n  async getNames() {\n    const { header, columnNames } = await this.loadData()\n    if (columnNames.length) {\n      return columnNames\n    }\n    const defs = header.split(/\\n|\\r\\n|\\r/).filter(f => !!f)\n    const defline = defs.at(-1)\n    return defline?.includes('\\t')\n      ? defline\n          .slice(1)\n          .split('\\t')\n          .map(field => field.trim())\n      : undefined\n  }\n\n  private async loadFeatureIntervalTreeHelper(refName: string) {\n    const { colRef, colStart, colEnd, features, parser, scoreColumn } =\n      await this.loadData()\n    const lines = features[refName]\n    if (!lines) {\n      return undefined\n    }\n    const names = await this.getNames()\n\n    const intervalTree = new IntervalTree()\n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i]!\n      const uniqueId = `${this.id}-${refName}-${i}`\n      const feat = new SimpleFeature(\n        featureData({\n          line,\n          colRef,\n          colStart,\n          colEnd,\n          scoreColumn,\n          parser,\n          uniqueId,\n          names,\n        }),\n      )\n      intervalTree.insert([feat.get('start'), feat.get('end')], feat)\n    }\n\n    return intervalTree\n  }\n\n  async loadFeatureIntervalTree(refName: string) {\n    if (!this.intervalTrees[refName]) {\n      this.intervalTrees[refName] = this.loadFeatureIntervalTreeHelper(\n        refName,\n      ).catch((e: unknown) => {\n        this.intervalTrees[refName] = undefined\n        throw e\n      })\n    }\n    return this.intervalTrees[refName]\n  }\n\n  public getFeatures(query: Region, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      const { start, end, refName } = query\n      const intervalTree = await this.loadFeatureIntervalTree(refName)\n      intervalTree?.search([start, end]).forEach(f => {\n        observer.next(f)\n      })\n      observer.complete()\n    }, opts.stopToken)\n  }\n\n  public freeResources(): void {}\n}\n","export function isRepeatMaskerDescriptionField(desc?: string): desc is string {\n  const ret = desc?.trim().split(' ')\n  return [0, 1, 2, 3, 5, 6].every(s =>\n    ret?.[s] !== undefined ? !Number.isNaN(+ret[s]) : false,\n  )\n}\n\nfunction makeRepeatTrackDescription(description?: string) {\n  if (isRepeatMaskerDescriptionField(description)) {\n    const [\n      bitsw_score,\n      percent_div,\n      percent_del,\n      percent_ins,\n      query_chr,\n      query_begin,\n      query_end,\n      query_remaining,\n      orientation,\n      matching_repeat_name,\n      matching_repeat_class,\n      matching_repeat_begin,\n      matching_repeat_end,\n      matching_repeat_remaining,\n      repeat_id,\n    ] = description.trim().split(' ')\n    return {\n      bitsw_score,\n      percent_div,\n      percent_del,\n      percent_ins,\n      query_chr,\n      query_begin,\n      query_end,\n      query_remaining,\n      orientation,\n      matching_repeat_name,\n      matching_repeat_class,\n      matching_repeat_begin,\n      matching_repeat_end,\n      matching_repeat_remaining,\n      repeat_id,\n    }\n  }\n  return { description }\n}\n\nexport function generateRepeatMaskerFeature({\n  uniqueId,\n  refName,\n  start,\n  end,\n  description,\n  ...rest\n}: {\n  uniqueId: string\n  refName: string\n  start: number\n  end: number\n  description: string\n  [key: string]: unknown\n}) {\n  return {\n    ...rest,\n    ...makeRepeatTrackDescription(description),\n    uniqueId,\n    refName,\n    start,\n    end,\n  }\n}\n","import BED from '@gmod/bed'\nimport { SimpleFeatureSerialized } from '@jbrowse/core/util'\nimport {\n  generateBedMethylFeature,\n  isBedMethylFeature,\n} from './generateBedMethylFeature'\nimport {\n  generateUcscTranscript,\n  isUcscTranscript,\n} from './generateUcscTranscript'\nimport {\n  generateRepeatMaskerFeature,\n  isRepeatMaskerDescriptionField,\n} from './generateRepeatMaskerFeature'\n\nfunction stringToStrand(f: string) {\n  if (f === '-1') {\n    return -1\n  } else if (f === '+') {\n    return 1\n  } else {\n    return 0\n  }\n}\n\nfunction defaultParser(fields: string[], line: string) {\n  const obj = Object.fromEntries(\n    line.split('\\t').map((f, i) => [fields[i]!, f] as const),\n  )\n  const {\n    blockStarts,\n    blockCount,\n    chromStarts,\n    thickEnd,\n    thickStart,\n    blockSizes,\n    ...rest\n  } = obj\n\n  return {\n    ...rest,\n    blockStarts: arrayify(blockStarts),\n    chromStarts: arrayify(chromStarts),\n    blockSizes: arrayify(blockSizes),\n    thickStart: thickStart ? +thickStart : undefined,\n    thickEnd: thickEnd ? +thickEnd : undefined,\n    blockCount: blockCount ? +blockCount : undefined,\n  } as Record<string, unknown>\n}\n\nexport function makeBlocks({\n  start,\n  uniqueId,\n  refName,\n  chromStarts,\n  blockCount,\n  blockSizes,\n  blockStarts,\n}: {\n  blockCount: number\n  start: number\n  uniqueId: string\n  refName: string\n  chromStarts?: number[]\n  blockSizes?: number[]\n  blockStarts?: number[]\n}) {\n  if (blockCount) {\n    const subfeatures = []\n    const starts = chromStarts || blockStarts || []\n    for (let b = 0; b < blockCount; b++) {\n      const bmin = (starts[b] || 0) + start\n      const bsize = blockSizes?.[b]\n      if (bsize && bsize > 0) {\n        const bmax = bmin + bsize\n        subfeatures.push({\n          uniqueId: `${uniqueId}-${b}`,\n          start: bmin,\n          end: bmax,\n          refName,\n          type: 'block',\n        })\n      }\n    }\n    return subfeatures\n  }\n  return []\n}\n\nexport function featureData({\n  line,\n  colRef,\n  colStart,\n  colEnd,\n  scoreColumn,\n  parser,\n  uniqueId,\n  names,\n}: {\n  line: string\n  colRef: number\n  colStart: number\n  colEnd: number\n  scoreColumn: string\n  parser: BED\n  uniqueId: string\n  names?: string[]\n}) {\n  const splitLine = line.split('\\t')\n  const refName = splitLine[colRef]!\n  const start = +splitLine[colStart]!\n  const end = +splitLine[colEnd]! + (colStart === colEnd ? 1 : 0)\n\n  return featureData2({\n    line,\n    refName,\n    start,\n    end,\n    parser,\n    uniqueId,\n    scoreColumn,\n    names,\n  })\n}\n\nexport function featureData2({\n  line,\n  refName,\n  start,\n  end,\n  parser,\n  uniqueId,\n  scoreColumn,\n  names,\n}: {\n  line: string\n  refName: string\n  start: number\n  end: number\n  parser: BED\n  uniqueId: string\n  scoreColumn: string\n  names?: string[]\n}): SimpleFeatureSerialized {\n  const splitLine = line.split('\\t')\n  const data = names\n    ? defaultParser(names, line)\n    : parser.parseLine(line, { uniqueId })\n  const {\n    strand: strand2,\n    score: score2,\n    chrom: _1,\n    chromStart: _2,\n    chromEnd: _3,\n    ...rest\n  } = data\n\n  const {\n    chromStarts,\n    blockSizes,\n    blockStarts,\n    type,\n    blockCount,\n    thickStart,\n    thickEnd,\n    description,\n    ...rest2\n  } = rest\n  const score = scoreColumn ? +data[scoreColumn] : score2 ? +score2 : undefined\n  const strand = typeof strand2 === 'string' ? stringToStrand(strand2) : strand2\n\n  const subfeatures = makeBlocks({\n    start,\n    uniqueId,\n    refName,\n    chromStarts,\n    blockCount,\n    blockSizes,\n    blockStarts,\n  })\n\n  if (isBedMethylFeature({ splitLine, start, end })) {\n    return generateBedMethylFeature({\n      line,\n      uniqueId,\n      refName,\n      start,\n      end,\n    })\n  } else if (isRepeatMaskerDescriptionField(description)) {\n    return generateRepeatMaskerFeature({\n      ...rest2,\n      uniqueId,\n      description,\n      type,\n      score,\n      start,\n      end,\n      strand,\n      refName,\n      subfeatures,\n    })\n  } else if (isUcscTranscript({ strand, blockCount, thickStart })) {\n    return generateUcscTranscript({\n      ...rest,\n      description,\n      chromStarts,\n      thickStart,\n      thickEnd,\n      blockSizes,\n      blockCount,\n      type,\n      score,\n      start,\n      end,\n      strand,\n      refName,\n      uniqueId,\n      subfeatures,\n    })\n  } else {\n    return {\n      ...rest,\n      uniqueId,\n      description,\n      type,\n      score,\n      start,\n      end,\n      strand,\n      refName,\n      subfeatures,\n    }\n  }\n}\n\nexport function arrayify(f?: string | number[]) {\n  return f !== undefined\n    ? typeof f === 'string'\n      ? f.split(',').map(f => +f)\n      : f\n    : undefined\n}\n","export function isBedMethylFeature({\n  splitLine,\n  start,\n  end,\n}: {\n  splitLine: string[]\n  start: number\n  end: number\n}) {\n  return +(splitLine[6] || 0) === start && +(splitLine[7] || 0) === end\n}\nexport function generateBedMethylFeature({\n  line,\n  uniqueId,\n  refName,\n  start,\n  end,\n}: {\n  line: string\n  uniqueId: string\n  refName: string\n  start: number\n  end: number\n}) {\n  // see\n  // https://github.com/nanoporetech/modkit?tab=readme-ov-file#description-of-bedmethyl-output\n  const [\n    ,\n    ,\n    ,\n    code,\n    ,\n    strand,\n    ,\n    ,\n    color,\n    n_valid_cov,\n    fraction_modified,\n    n_mod,\n    n_canonical,\n    n_other_mod,\n    n_delete,\n    n_fail,\n    n_diff,\n    n_nocall,\n  ] = line.split('\\t')\n\n  return {\n    uniqueId,\n    refName,\n    start,\n    end,\n    code,\n    score: +fraction_modified! || 0,\n    strand,\n    color,\n    source: code,\n    n_valid_cov,\n    fraction_modified,\n    n_mod,\n    n_canonical,\n    n_other_mod,\n    n_delete,\n    n_fail,\n    n_diff,\n    n_nocall,\n  }\n}\n","import { MinimalFeature, TranscriptFeat } from './types'\n\nexport function isUcscTranscript({\n  thickStart,\n  blockCount,\n  strand,\n}: {\n  thickStart?: number\n  blockCount?: number\n  strand?: number\n}) {\n  return thickStart && blockCount && strand !== 0\n}\n\nexport function generateUcscTranscript(data: TranscriptFeat) {\n  const {\n    strand = 0,\n    chrom: _1,\n    chromStart: _2,\n    chromEnd: _3,\n    chromStarts,\n    blockStarts,\n    blockSizes,\n    uniqueId,\n    ...rest\n  } = data\n  const {\n    subfeatures: oldSubfeatures,\n    thickStart,\n    thickEnd,\n    blockCount,\n    refName,\n    ...rest2\n  } = rest\n\n  const subfeatures: MinimalFeature[] = []\n  const feats = oldSubfeatures\n    .filter(child => child.type === 'block')\n    .sort((a, b) => a.start - b.start)\n\n  for (const block of feats) {\n    const start = block.start\n    const end = block.end\n    if (thickStart >= end) {\n      // left-side UTR\n      subfeatures.push({\n        type: `${strand > 0 ? 'five' : 'three'}_prime_UTR`,\n        start,\n        end,\n        refName,\n      })\n    } else if (thickStart > start && thickStart < end && thickEnd >= end) {\n      // UTR | CDS\n      subfeatures.push(\n        {\n          type: `${strand > 0 ? 'five' : 'three'}_prime_UTR`,\n          start,\n          end: thickStart,\n          refName,\n        },\n        {\n          type: 'CDS',\n          start: thickStart,\n          end,\n          refName,\n        },\n      )\n    } else if (thickStart <= start && thickEnd >= end) {\n      // CDS\n      subfeatures.push({\n        type: 'CDS',\n        start,\n        end,\n        refName,\n      })\n    } else if (thickStart > start && thickStart < end && thickEnd < end) {\n      // UTR | CDS | UTR\n      subfeatures.push(\n        {\n          type: `${strand > 0 ? 'five' : 'three'}_prime_UTR`,\n          start,\n          end: thickStart,\n          refName,\n        },\n        {\n          type: 'CDS',\n          start: thickStart,\n          end: thickEnd,\n          refName,\n        },\n        {\n          type: `${strand > 0 ? 'three' : 'five'}_prime_UTR`,\n          start: thickEnd,\n          end,\n          refName,\n        },\n      )\n    } else if (thickStart <= start && thickEnd > start && thickEnd < end) {\n      // CDS | UTR\n      subfeatures.push(\n        {\n          type: 'CDS',\n          start,\n          end: thickEnd,\n          refName,\n        },\n        {\n          type: `${strand > 0 ? 'three' : 'five'}_prime_UTR`,\n          start: thickEnd,\n          end,\n          refName,\n        },\n      )\n    } else if (thickEnd <= start) {\n      // right-side UTR\n      subfeatures.push({\n        type: `${strand > 0 ? 'three' : 'five'}_prime_UTR`,\n        start,\n        end,\n        refName,\n      })\n    }\n  }\n\n  return {\n    ...rest2,\n    uniqueId,\n    strand,\n    type: 'mRNA',\n    refName,\n    subfeatures,\n  }\n}\n"],"names":["BedAdapter","BaseFeatureDataAdapter","intervalTrees","loadDataP","opts","pm","this","pluginManager","bedLoc","getConf","buffer","fetchAndMaybeUnzip","openLocation","length","Error","lines","TextDecoder","fatal","decode","split","filter","f","headerLines","i","startsWith","push","header","join","features","line","tab","indexOf","refName","slice","autoSql","parser","BED","columnNames","scoreColumn","colRef","colStart","colEnd","loadData","bedFeatures","catch","e","undefined","getRefNames","Object","keys","getHeader","getNames","defline","at","includes","map","field","trim","loadFeatureIntervalTreeHelper","names","intervalTree","IntervalTree","uniqueId","id","feat","SimpleFeature","featureData","insert","get","loadFeatureIntervalTree","getFeatures","query","ObservableCreate","async","start","end","search","forEach","observer","next","complete","stopToken","freeResources","isRepeatMaskerDescriptionField","desc","ret","every","s","Number","isNaN","makeRepeatTrackDescription","description","bitsw_score","percent_div","percent_del","percent_ins","query_chr","query_begin","query_end","query_remaining","orientation","matching_repeat_name","matching_repeat_class","matching_repeat_begin","matching_repeat_end","matching_repeat_remaining","repeat_id","splitLine","featureData2","data","fields","obj","fromEntries","blockStarts","blockCount","chromStarts","thickEnd","thickStart","blockSizes","rest","arrayify","defaultParser","parseLine","strand","strand2","score","score2","chrom","_1","chromStart","_2","chromEnd","_3","type","rest2","subfeatures","starts","b","bmin","bsize","bmax","makeBlocks","isBedMethylFeature","code","color","n_valid_cov","fraction_modified","n_mod","n_canonical","n_other_mod","n_delete","n_fail","n_diff","n_nocall","source","generateBedMethylFeature","generateRepeatMaskerFeature","isUcscTranscript","oldSubfeatures","feats","child","sort","a","block","generateUcscTranscript"],"sourceRoot":""}