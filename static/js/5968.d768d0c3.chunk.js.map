{"version":3,"file":"static/js/5968.d768d0c3.chunk.js","mappings":"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","sources":["../../../plugins/breakpoint-split-view/src/BreakpointSplitView/components/BreakpointSplitViewOverlay.tsx","../../../plugins/breakpoint-split-view/src/BreakpointSplitView/components/BreakpointSplitView.tsx","../../../plugins/breakpoint-split-view/src/BreakpointSplitView/components/util.ts","../../../plugins/breakpoint-split-view/src/BreakpointSplitView/components/AlignmentConnections.tsx","../../../plugins/breakpoint-split-view/src/BreakpointSplitView/components/Breakends.tsx","../../../plugins/breakpoint-split-view/src/BreakpointSplitView/components/Translocations.tsx","../../../plugins/breakpoint-split-view/src/BreakpointSplitView/components/Overlay.tsx"],"sourcesContent":["import React, { useRef } from 'react'\n\nimport { makeStyles } from 'tss-react/mui'\n\nimport Overlay from './Overlay'\nimport { BreakpointViewModel } from '../model'\nimport { observer } from 'mobx-react'\n\nconst useStyles = makeStyles()({\n  overlay: {\n    display: 'flex',\n    width: '100%',\n    gridArea: '1/1',\n    '& path': {\n      cursor: 'crosshair',\n      fill: 'none',\n    },\n  },\n})\n\nconst BreakpointSplitViewOverlay = observer(function ({\n  model,\n}: {\n  model: BreakpointViewModel\n}) {\n  const { classes } = useStyles()\n  const { matchedTracks, interactToggled } = model\n  const ref = useRef(null)\n  return (\n    <div className={classes.overlay}>\n      <svg\n        ref={ref}\n        style={{\n          width: '100%',\n          zIndex: 10,\n          pointerEvents: interactToggled ? undefined : 'none',\n        }}\n      >\n        {matchedTracks.map(track => (\n          // note: we must pass ref down, because the child component needs to\n          // getBoundingClientRect on the this components SVG, and we cannot\n          // rely on using getBoundingClientRect in this component to make\n          // sure this works because if it gets shifted around by another\n          // element, this will not re-render necessarily\n          <Overlay\n            parentRef={ref}\n            key={track.configuration.trackId}\n            model={model}\n            trackId={track.configuration.trackId}\n          />\n        ))}\n      </svg>\n    </div>\n  )\n})\n\nexport default BreakpointSplitViewOverlay\n","import React from 'react'\nimport { observer } from 'mobx-react'\nimport { getEnv } from 'mobx-state-tree'\nimport { makeStyles } from 'tss-react/mui'\n\n// locals\nimport { BreakpointViewModel } from '../model'\nimport BreakpointSplitViewOverlay from './BreakpointSplitViewOverlay'\n\nconst useStyles = makeStyles()(theme => ({\n  viewDivider: {\n    background: theme.palette.secondary.main,\n    height: 3,\n  },\n  container: {\n    display: 'grid',\n  },\n\n  content: {\n    gridArea: '1/1',\n  },\n}))\n\nconst BreakpointSplitViewLevels = observer(function ({\n  model,\n}: {\n  model: BreakpointViewModel\n}) {\n  const { classes } = useStyles()\n  const { views } = model\n  const { pluginManager } = getEnv(model)\n  return (\n    <div className={classes.content}>\n      <div style={{ position: 'relative' }}>\n        {views.map((view, idx) => {\n          const { ReactComponent } = pluginManager.getViewType(view.type)\n          const viewComponent = <ReactComponent key={view.id} model={view} />\n          if (idx === views.length - 1) {\n            return viewComponent\n          }\n          return [\n            viewComponent,\n            <div key={`${view.id}-divider`} className={classes.viewDivider} />,\n          ]\n        })}\n      </div>\n    </div>\n  )\n})\n\nconst BreakpointSplitView = observer(function ({\n  model,\n}: {\n  model: BreakpointViewModel\n}) {\n  const { classes } = useStyles()\n  return (\n    <div>\n      <div className={classes.container}>\n        <BreakpointSplitViewLevels model={model} />\n        <BreakpointSplitViewOverlay model={model} />\n      </div>\n    </div>\n  )\n})\n\nexport default BreakpointSplitView\n","import { Feature, notEmpty } from '@jbrowse/core/util'\n\nimport { parseBreakend } from '@gmod/vcf'\n\n// this finds candidate alignment features, aimed at plotting split reads from\n// BAM/CRAM files\nexport function getBadlyPairedAlignments(features: Map<string, Feature>) {\n  const candidates = new Map<string, Feature[]>()\n  const alreadySeen = new Set<string>()\n\n  // this finds candidate features that share the same name\n  for (const feature of features.values()) {\n    const flags = feature.get('flags')\n    const id = feature.id()\n    const unmapped = flags & 4\n    const correctlyPaired = flags & 2\n\n    if (!alreadySeen.has(id) && !correctlyPaired && !unmapped) {\n      const n = feature.get('name')\n      let val = candidates.get(n)\n      if (!val) {\n        val = []\n        candidates.set(n, val)\n      }\n      val.push(feature)\n    }\n    alreadySeen.add(feature.id())\n  }\n\n  return [...candidates.values()].filter(v => v.length > 1)\n}\n\nfunction getTag(f: Feature, tag: string) {\n  const tags = f.get('tags')\n  return tags ? tags[tag] : f.get(tag)\n}\n\n// this finds candidate alignment features, aimed at plotting split reads from\n// BAM/CRAM files\nexport function getMatchedAlignmentFeatures(features: Map<string, Feature>) {\n  const candidates = new Map<string, Feature[]>()\n  const alreadySeen = new Set<string>()\n\n  // this finds candidate features that share the same name\n  for (const feature of features.values()) {\n    const id = feature.id()\n    const unmapped = feature.get('flags') & 4\n    const hasSA = !!getTag(feature, 'SA')\n    if (!alreadySeen.has(id) && !unmapped && hasSA) {\n      const n = feature.get('name')\n      let val = candidates.get(n)\n      if (!val) {\n        val = []\n        candidates.set(n, val)\n      }\n      val.push(feature)\n    }\n    alreadySeen.add(feature.id())\n  }\n\n  return [...candidates.values()].filter(v => v.length > 1)\n}\n\nexport function hasPairedReads(features: Map<string, Feature>) {\n  for (const f of features.values()) {\n    if (f.get('flags') & 1) {\n      return true\n    }\n  }\n  return false\n}\n\nexport function findMatchingAlt(feat1: Feature, feat2: Feature) {\n  const alts = feat1.get('ALT') as string[] | undefined\n  if (alts) {\n    return new Map(\n      alts\n        ?.map(alt => parseBreakend(alt))\n        .filter(notEmpty)\n        .map(bnd => [bnd.MatePosition, bnd]),\n    ).get(`${feat2.get('refName')}:${feat2.get('start') + 1}`)\n  }\n  return undefined\n}\n\n// Returns paired BND features across multiple views by inspecting the ALT\n// field to get exact coordinate matches\nexport function getMatchedBreakendFeatures(feats: Map<string, Feature>) {\n  const candidates = new Map<string, Feature[]>()\n  const alreadySeen = new Set<string>()\n\n  for (const f of feats.values()) {\n    if (!alreadySeen.has(f.id()) && f.get('type') === 'breakend') {\n      const alts = f.get('ALT') as string[] | undefined\n      alts?.forEach(a => {\n        const cur = `${f.get('refName')}:${f.get('start') + 1}`\n        const bnd = parseBreakend(a)\n        if (bnd) {\n          const val = candidates.get(cur)\n          if (!val) {\n            candidates.set(bnd.MatePosition || 'none', [f])\n          } else {\n            val.push(f)\n          }\n        }\n      })\n    }\n    alreadySeen.add(f.id())\n  }\n\n  return [...candidates.values()].filter(v => v.length > 1)\n}\n\n// Getting \"matched\" TRA means just return all TRA\nexport function getMatchedTranslocationFeatures(feats: Map<string, Feature>) {\n  const ret: Feature[][] = []\n  const alreadySeen = new Set<string>()\n\n  for (const f of feats.values()) {\n    if (!alreadySeen.has(f.id()) && f.get('ALT')[0] === '<TRA>') {\n      ret.push([f])\n    }\n    alreadySeen.add(f.id())\n  }\n\n  return ret\n}\n","import React, { useMemo, useState } from 'react'\nimport { observer } from 'mobx-react'\nimport { getSnapshot } from 'mobx-state-tree'\nimport { useTheme } from '@mui/material'\nimport { getSession } from '@jbrowse/core/util'\n\n// locals\nimport {\n  getBadlyPairedAlignments,\n  getMatchedAlignmentFeatures,\n  hasPairedReads,\n} from './util'\nimport { yPos, useNextFrame, getPxFromCoordinate } from '../util'\nimport { BreakpointViewModel } from '../model'\n\nconst [LEFT, , RIGHT] = [0, 1, 2, 3]\n\nconst AlignmentConnections = observer(function ({\n  model,\n  trackId,\n  parentRef,\n  getTrackYPosOverride,\n}: {\n  model: BreakpointViewModel\n  trackId: string\n  parentRef: React.RefObject<SVGSVGElement>\n  getTrackYPosOverride?: (trackId: string, level: number) => number\n}) {\n  const { views, showIntraviewLinks } = model\n  const theme = useTheme()\n  const session = getSession(model)\n  const snap = getSnapshot(model)\n  const { assemblyManager } = session\n  const assembly = assemblyManager.get(views[0].assemblyNames[0])\n  useNextFrame(snap)\n  const allFeatures = model.getTrackFeatures(trackId)\n  const hasPaired = useMemo(() => hasPairedReads(allFeatures), [allFeatures])\n\n  const layoutMatches = useMemo(() => {\n    const layoutMatches = model.getMatchedFeaturesInLayout(\n      trackId,\n      hasPaired\n        ? getBadlyPairedAlignments(allFeatures)\n        : getMatchedAlignmentFeatures(allFeatures),\n    )\n    if (!hasPaired) {\n      layoutMatches.forEach(m => {\n        m.sort((a, b) => a.feature.get('clipPos') - b.feature.get('clipPos'))\n      })\n    }\n    return layoutMatches\n  }, [allFeatures, trackId, hasPaired, model])\n\n  const [mouseoverElt, setMouseoverElt] = useState<string>()\n\n  let yOffset = 0\n  if (parentRef.current) {\n    const rect = parentRef.current.getBoundingClientRect()\n    yOffset = rect.top\n  }\n\n  if (!assembly) {\n    return null\n  }\n\n  return (\n    <g\n      stroke={theme.palette.text.disabled}\n      fill=\"none\"\n      data-testid={layoutMatches.length ? `${trackId}-loaded` : trackId}\n    >\n      {layoutMatches.map(chunk => {\n        const ret = []\n        // we follow a path in the list of chunks, not from top to bottom, just in series\n        // following x1,y1 -> x2,y2\n        for (let i = 0; i < chunk.length - 1; i++) {\n          const { layout: c1, feature: f1, level: level1 } = chunk[i]\n          const { layout: c2, feature: f2, level: level2 } = chunk[i + 1]\n\n          if (!c1 || !c2) {\n            console.warn('received null layout for a overlay feature')\n            return null\n          }\n\n          // disable rendering connections in a single level\n          if (!showIntraviewLinks && level1 === level2) {\n            return null\n          }\n          const f1ref = assembly.getCanonicalRefName(f1.get('refName'))\n          const f2ref = assembly.getCanonicalRefName(f2.get('refName'))\n\n          if (!f1ref || !f2ref) {\n            throw new Error(`unable to find ref for ${f1ref || f2ref}`)\n          }\n\n          const s1 = f1.get('strand')\n          const s2 = f2.get('strand')\n          const p1 = c1[s1 === -1 ? LEFT : RIGHT]\n          const sn1 = s2 === -1\n          const p2 = hasPaired ? c2[sn1 ? LEFT : RIGHT] : c2[sn1 ? RIGHT : LEFT]\n          const x1 = getPxFromCoordinate(views[level1], f1ref, p1)\n          const x2 = getPxFromCoordinate(views[level2], f2ref, p2)\n          const reversed1 = views[level1].pxToBp(x1).reversed\n          const reversed2 = views[level2].pxToBp(x2).reversed\n          const tracks = views.map(v => v.getTrack(trackId))\n          const y1 =\n            yPos(trackId, level1, views, tracks, c1, getTrackYPosOverride) -\n            yOffset\n          const y2 =\n            yPos(trackId, level2, views, tracks, c2, getTrackYPosOverride) -\n            yOffset\n\n          // possible todo: use totalCurveHeight to possibly make alternative\n          // squiggle if the S is too small\n          const path = [\n            'M',\n            x1,\n            y1,\n            'C',\n            x1 + 200 * f1.get('strand') * (reversed1 ? -1 : 1),\n            y1,\n            x2 -\n              200 *\n                f2.get('strand') *\n                (reversed2 ? -1 : 1) *\n                (hasPaired ? -1 : 1),\n            y2,\n            x2,\n            y2,\n          ].join(' ')\n          const id = `${f1.id()}-${f2.id()}`\n          ret.push(\n            <path\n              d={path}\n              key={id}\n              data-testid=\"r1\"\n              strokeWidth={mouseoverElt === id ? 5 : 1}\n              onClick={() => {\n                const featureWidget = session.addWidget?.(\n                  'BreakpointAlignmentsWidget',\n                  'breakpointAlignments',\n                  {\n                    featureData: {\n                      feature1: (\n                        allFeatures.get(f1.id()) || { toJSON: () => {} }\n                      ).toJSON(),\n                      feature2: (\n                        allFeatures.get(f2.id()) || { toJSON: () => {} }\n                      ).toJSON(),\n                    },\n                  },\n                )\n                session.showWidget?.(featureWidget)\n              }}\n              onMouseOver={() => setMouseoverElt(id)}\n              onMouseOut={() => setMouseoverElt(undefined)}\n            />,\n          )\n        }\n        return ret\n      })}\n    </g>\n  )\n})\n\nexport default AlignmentConnections\n","import React, { useState, useMemo } from 'react'\nimport { getSession } from '@jbrowse/core/util'\nimport { observer } from 'mobx-react'\nimport { getSnapshot } from 'mobx-state-tree'\n\n// locals\nimport { findMatchingAlt, getMatchedBreakendFeatures } from './util'\nimport { yPos, getPxFromCoordinate, useNextFrame } from '../util'\nimport { BreakpointViewModel } from '../model'\n\nconst [LEFT] = [0, 1, 2, 3]\n\nconst Breakends = observer(function ({\n  model,\n  trackId,\n  parentRef: ref,\n  getTrackYPosOverride,\n}: {\n  model: BreakpointViewModel\n  trackId: string\n  parentRef: React.RefObject<SVGSVGElement>\n  getTrackYPosOverride?: (trackId: string, level: number) => number\n}) {\n  const { views } = model\n  const session = getSession(model)\n  const { assemblyManager } = session\n  const totalFeatures = model.getTrackFeatures(trackId)\n  const layoutMatches = useMemo(\n    () =>\n      model.getMatchedFeaturesInLayout(\n        trackId,\n        getMatchedBreakendFeatures(totalFeatures),\n      ),\n    [totalFeatures, trackId, model],\n  )\n\n  const [mouseoverElt, setMouseoverElt] = useState<string>()\n  const snap = getSnapshot(model)\n  useNextFrame(snap)\n  const assembly = assemblyManager.get(views[0].assemblyNames[0])\n\n  if (!assembly) {\n    return null\n  }\n\n  let yoff = 0\n  if (ref.current) {\n    const rect = ref.current.getBoundingClientRect()\n    yoff = rect.top\n  }\n\n  return (\n    <g\n      stroke=\"green\"\n      strokeWidth={5}\n      fill=\"none\"\n      data-testid={layoutMatches.length ? `${trackId}-loaded` : trackId}\n    >\n      {layoutMatches.map(chunk => {\n        const ret = []\n        // we follow a path in the list of chunks, not from top to bottom, just\n        // in series following x1,y1 -> x2,y2\n        for (let i = 0; i < chunk.length - 1; i += 1) {\n          const { layout: c1, feature: f1, level: level1 } = chunk[i]\n          const { layout: c2, feature: f2, level: level2 } = chunk[i + 1]\n          const id = f1.id()\n\n          const relevantAlt = findMatchingAlt(f1, f2)\n          if (!c1 || !c2) {\n            return null\n          }\n          const f1origref = f1.get('refName')\n          const f2origref = f2.get('refName')\n          const f1ref = assembly.getCanonicalRefName(f1origref)\n          const f2ref = assembly.getCanonicalRefName(f2origref)\n          if (!f1ref || !f2ref) {\n            throw new Error(`unable to find ref for ${f1ref || f2ref}`)\n          }\n          const x1 = getPxFromCoordinate(views[level1], f1ref, c1[LEFT])\n          const x2 = getPxFromCoordinate(views[level2], f2ref, c2[LEFT])\n          const reversed1 = views[level1].pxToBp(x1).reversed\n          const reversed2 = views[level2].pxToBp(x2).reversed\n\n          const tracks = views.map(v => v.getTrack(trackId))\n          const y1 =\n            yPos(trackId, level1, views, tracks, c1, getTrackYPosOverride) -\n            yoff\n          const y2 =\n            yPos(trackId, level2, views, tracks, c2, getTrackYPosOverride) -\n            yoff\n          if (!relevantAlt) {\n            console.warn('the relevant ALT allele was not found, cannot render')\n          } else {\n            const path = [\n              'M', // move to\n              x1 -\n                20 *\n                  (relevantAlt.Join === 'left' ? -1 : 1) *\n                  (reversed1 ? -1 : 1),\n              y1,\n              'L', // line to\n              x1,\n              y1,\n              'L', // line to\n              x2,\n              y2,\n              'L', // line to\n              x2 -\n                20 *\n                  (relevantAlt.MateDirection === 'left' ? 1 : -1) *\n                  (reversed2 ? -1 : 1),\n              y2,\n            ].join(' ')\n            ret.push(\n              <path\n                d={path}\n                key={JSON.stringify(path)}\n                strokeWidth={id === mouseoverElt ? 10 : 5}\n                onClick={() => {\n                  const featureWidget = session.addWidget?.(\n                    'VariantFeatureWidget',\n                    'variantFeature',\n                    {\n                      featureData: totalFeatures.get(id)?.toJSON(),\n                    },\n                  )\n                  session.showWidget?.(featureWidget)\n                }}\n                onMouseOver={() => setMouseoverElt(id)}\n                onMouseOut={() => setMouseoverElt(undefined)}\n              />,\n            )\n          }\n        }\n        return ret\n      })}\n    </g>\n  )\n})\n\nexport default Breakends\n","import React, { useState, useMemo } from 'react'\nimport { getSession } from '@jbrowse/core/util'\nimport { observer } from 'mobx-react'\nimport { getSnapshot } from 'mobx-state-tree'\n\n// locals\nimport { getMatchedTranslocationFeatures } from './util'\nimport { yPos, getPxFromCoordinate, useNextFrame } from '../util'\nimport { BreakpointViewModel, LayoutRecord } from '../model'\n\nconst [LEFT] = [0, 1, 2, 3]\n\nconst Translocations = observer(function ({\n  model,\n  trackId,\n  parentRef: ref,\n  getTrackYPosOverride,\n}: {\n  model: BreakpointViewModel\n  trackId: string\n  parentRef: React.RefObject<SVGSVGElement>\n  getTrackYPosOverride?: (trackId: string, level: number) => number\n}) {\n  const { views } = model\n  const session = getSession(model)\n  const { assemblyManager } = session\n  const totalFeatures = model.getTrackFeatures(trackId)\n  const layoutMatches = useMemo(\n    () =>\n      model.getMatchedFeaturesInLayout(\n        trackId,\n        getMatchedTranslocationFeatures(totalFeatures),\n      ),\n\n    [totalFeatures, trackId, model],\n  )\n\n  const [mouseoverElt, setMouseoverElt] = useState<string>()\n  const snap = getSnapshot(model)\n  useNextFrame(snap)\n\n  const assembly = assemblyManager.get(views[0].assemblyNames[0])\n  if (!assembly) {\n    return null\n  }\n\n  let yOffset = 0\n  if (ref.current) {\n    const rect = ref.current.getBoundingClientRect()\n    yOffset = rect.top\n  }\n\n  // we hardcode the TRA to go to the \"other view\" and if there is none, we\n  // just return null here note: would need to do processing of the INFO\n  // CHR2/END and see which view could contain those coordinates to really do\n  // it properly\n  if (views.length < 2) {\n    return null\n  }\n  return (\n    <g\n      fill=\"none\"\n      stroke=\"green\"\n      strokeWidth={5}\n      data-testid={layoutMatches.length ? `${trackId}-loaded` : trackId}\n    >\n      {layoutMatches.map(chunk => {\n        // we follow a path in the list of chunks, not from top to bottom,\n        // just in series following x1,y1 -> x2,y2\n        const ret = []\n        for (const { layout: c1, feature: f1, level: level1 } of chunk) {\n          const level2 = level1 === 0 ? 1 : 0\n          const id = f1.id()\n          if (!c1) {\n            return null\n          }\n\n          const info = f1.get('INFO')\n          const chr2 = info.CHR2[0]\n          const end2 = info.END[0]\n          const [myDirection, mateDirection] = info.STRANDS[0].split('')\n\n          const r = getPxFromCoordinate(views[level2], chr2, end2)\n          if (r) {\n            const c2: LayoutRecord = [r, 0, r + 1, 0]\n            const x1 = getPxFromCoordinate(\n              views[level1],\n              f1.get('refName'),\n              c1[LEFT],\n            )\n            const x2 = r\n            const reversed1 = views[level1].pxToBp(x1).reversed\n            const reversed2 = views[level2].pxToBp(x2).reversed\n\n            const tracks = views.map(v => v.getTrack(trackId))\n            const y1 =\n              yPos(trackId, level1, views, tracks, c1, getTrackYPosOverride) -\n              yOffset\n            const y2 =\n              yPos(trackId, level2, views, tracks, c2, getTrackYPosOverride) -\n              yOffset\n\n            const path = [\n              'M', // move to\n              x1 - 20 * (myDirection === '+' ? 1 : -1) * (reversed1 ? -1 : 1),\n              y1,\n              'L', // line to\n              x1,\n              y1,\n              'L', // line to\n              x2,\n              y2,\n              'L', // line to\n              x2 - 20 * (mateDirection === '+' ? 1 : -1) * (reversed2 ? -1 : 1),\n              y2,\n            ].join(' ')\n            ret.push(\n              <path\n                d={path}\n                key={JSON.stringify(path)}\n                strokeWidth={id === mouseoverElt ? 10 : 5}\n                onClick={() => {\n                  const featureWidget = session.addWidget?.(\n                    'VariantFeatureWidget',\n                    'variantFeature',\n                    {\n                      featureData: (\n                        totalFeatures.get(id) || { toJSON: () => {} }\n                      ).toJSON(),\n                    },\n                  )\n                  session.showWidget?.(featureWidget)\n                }}\n                onMouseOver={() => setMouseoverElt(id)}\n                onMouseOut={() => setMouseoverElt(undefined)}\n              />,\n            )\n          }\n        }\n        return ret\n      })}\n    </g>\n  )\n})\n\nexport default Translocations\n","import React from 'react'\nimport { observer } from 'mobx-react'\n\n// locals\nimport { BreakpointViewModel } from '../model'\nimport AlignmentConnections from './AlignmentConnections'\nimport Breakends from './Breakends'\nimport Translocations from './Translocations'\n\nconst Overlay = observer(function (props: {\n  parentRef: React.RefObject<SVGSVGElement>\n  model: BreakpointViewModel\n  trackId: string\n  getTrackYPosOverride?: (trackId: string, level: number) => number\n}) {\n  const { model, trackId } = props\n  const tracks = model.getMatchedTracks(trackId)\n  if (tracks[0]?.type === 'AlignmentsTrack') {\n    return <AlignmentConnections {...props} />\n  }\n  if (tracks[0]?.type === 'VariantTrack') {\n    return model.hasTranslocations(trackId) ? (\n      <Translocations {...props} />\n    ) : (\n      <Breakends {...props} />\n    )\n  }\n  return null\n})\n\nexport default Overlay\n"],"names":["useStyles","makeStyles","overlay","display","width","gridArea","cursor","fill","observer","_ref","model","classes","matchedTracks","interactToggled","ref","useRef","_jsx","className","children","style","zIndex","pointerEvents","undefined","map","track","Overlay","parentRef","trackId","configuration","theme","viewDivider","background","palette","secondary","main","height","container","content","BreakpointSplitViewLevels","views","pluginManager","getEnv","position","view","idx","ReactComponent","getViewType","type","viewComponent","id","length","concat","_ref2","_jsxs","BreakpointSplitViewOverlay","getTag","f","tag","tags","get","findMatchingAlt","feat1","feat2","alts","Map","alt","parseBreakend","filter","notEmpty","bnd","MatePosition","LEFT","RIGHT","getTrackYPosOverride","showIntraviewLinks","useTheme","session","getSession","snap","getSnapshot","assemblyManager","assembly","assemblyNames","useNextFrame","allFeatures","getTrackFeatures","hasPaired","useMemo","features","values","hasPairedReads","layoutMatches","getMatchedFeaturesInLayout","candidates","alreadySeen","Set","feature","flags","unmapped","correctlyPaired","has","n","val","set","push","add","v","getBadlyPairedAlignments","hasSA","getMatchedAlignmentFeatures","forEach","m","sort","a","b","mouseoverElt","setMouseoverElt","useState","yOffset","current","rect","getBoundingClientRect","top","stroke","text","disabled","chunk","ret","i","layout","c1","f1","level","level1","c2","f2","level2","console","warn","f1ref","getCanonicalRefName","f2ref","Error","s1","s2","p1","sn1","p2","x1","getPxFromCoordinate","x2","reversed1","pxToBp","reversed","reversed2","tracks","getTrack","y1","yPos","y2","path","join","d","strokeWidth","onClick","_session$addWidget","_session$showWidget","featureWidget","addWidget","call","featureData","feature1","toJSON","feature2","showWidget","onMouseOver","onMouseOut","totalFeatures","feats","cur","getMatchedBreakendFeatures","yoff","relevantAlt","f1origref","f2origref","Join","MateDirection","_totalFeatures$get","JSON","stringify","getMatchedTranslocationFeatures","info","chr2","CHR2","end2","END","myDirection","mateDirection","STRANDS","split","r","props","_tracks$","_tracks$2","getMatchedTracks","AlignmentConnections","hasTranslocations","Translocations","Breakends"],"sourceRoot":""}