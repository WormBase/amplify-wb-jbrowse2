{"version":3,"file":"static/js/1564.ba1e21d0.chunk.js","mappings":"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","sources":["../../../plugins/spreadsheet-view/src/SpreadsheetView/importAdapters/ImportUtils.ts","../../../plugins/spreadsheet-view/src/SpreadsheetView/importAdapters/VcfImport.ts"],"sourcesContent":["import { parseLocString } from '@jbrowse/core/util'\n\nexport function bufferToString(buffer: Buffer) {\n  return new TextDecoder('utf8', { fatal: true }).decode(buffer)\n}\n\nasync function parseWith(buffer: Buffer, options = {}) {\n  const csv = await import('csvtojson').then(module => module.default)\n  return csv({ noheader: true, output: 'csv', ...options }).fromString(\n    bufferToString(buffer),\n  )\n}\n\nexport interface Row {\n  id: string\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  extendedData?: any\n  cells: {\n    text: string\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    extendedData?: any\n  }[]\n}\n\nexport interface RowSet {\n  isLoaded: boolean\n  rows: Row[]\n}\n\nexport interface ParseOptions {\n  hasColumnNameLine?: boolean\n  columnNameLineNumber?: number\n  selectedAssemblyName?: string\n  isValidRefName?: (refName: string, assemblyName?: string) => boolean\n}\n\nexport interface Column {\n  name: string\n  dataType: { type: string }\n  isDerived?: boolean\n  derivationFunctionText?: string\n}\n\nfunction guessColumnType(\n  rowSet: RowSet,\n  columnNumber: number,\n  isValidRefName: (refName: string, assemblyName?: string) => boolean,\n) {\n  const text = rowSet.rows[0].cells[columnNumber].text || ''\n\n  let guessedType = 'Text'\n\n  let parsedLoc\n  try {\n    parsedLoc = parseLocString(text, isValidRefName)\n  } catch (error) {\n    //\n  }\n  if (parsedLoc?.refName && typeof parsedLoc.start === 'number') {\n    guessedType = 'LocString'\n  } else if (/^\\d+(\\.\\d+)?$/.test(text)) {\n    guessedType = 'Number'\n  }\n\n  // MAYBE TODO: iterate over the rest of the rows to confirm\n  // the type for all the rows\n\n  return guessedType\n}\n\nfunction dataToSpreadsheetSnapshot(\n  rows: string[][],\n  options: ParseOptions = {},\n) {\n  const {\n    hasColumnNameLine = false,\n    columnNameLineNumber = 1,\n    isValidRefName = () => false,\n    selectedAssemblyName,\n  } = options\n  // rows is an array of row objects and columnNames\n  // is an array of column names (in import order)\n  let maxCols = 0\n  const rowSet: RowSet = {\n    isLoaded: true,\n    rows: rows.map((row, rowNumber) => {\n      const id = rowNumber + (hasColumnNameLine ? 0 : 1)\n      if (row.length > maxCols) {\n        maxCols = row.length\n      }\n      return {\n        id: String(id),\n        cells: row.map((text, columnNumber) => {\n          return { columnNumber, text }\n        }),\n      }\n    }),\n  }\n\n  // process the column names row if present\n  const columnNames: Record<string, string> = {}\n  if (hasColumnNameLine && columnNameLineNumber !== undefined) {\n    const [colNamesRow] = rowSet.rows.splice(columnNameLineNumber - 1, 1)\n\n    if (colNamesRow) {\n      colNamesRow.cells.forEach((cell, columnNumber) => {\n        columnNames[columnNumber] = cell.text || ''\n      })\n    }\n  }\n\n  // make our column definitions\n  const columns: Column[] = []\n  const columnDisplayOrder = []\n  for (let columnNumber = 0; columnNumber < maxCols; columnNumber += 1) {\n    columnDisplayOrder.push(columnNumber)\n    const guessedType = guessColumnType(rowSet, columnNumber, isValidRefName)\n\n    // store extendeddata for LocString column\n    if (guessedType === 'LocString') {\n      for (const row of rowSet.rows) {\n        const cell = row.cells[columnNumber]\n        cell.extendedData = parseLocString(cell.text, isValidRefName)\n      }\n    }\n\n    columns[columnNumber] = {\n      name: columnNames[columnNumber],\n      dataType: {\n        type: guessedType,\n      },\n    }\n  }\n\n  return {\n    rowSet,\n    columnDisplayOrder,\n    hasColumnNames: !!hasColumnNameLine,\n    columns,\n    assemblyName: selectedAssemblyName,\n  }\n}\n\nexport async function parseCsvBuffer(buffer: Buffer, options?: ParseOptions) {\n  const rows = await parseWith(buffer)\n  return dataToSpreadsheetSnapshot(rows, options)\n}\n\nexport async function parseTsvBuffer(buffer: Buffer, options?: ParseOptions) {\n  const rows = await parseWith(buffer, { delimiter: '\\t' })\n  return dataToSpreadsheetSnapshot(rows, options)\n}\n","import VCF from '@gmod/vcf'\nimport { VcfFeature } from '@jbrowse/plugin-variants'\nimport {\n  bufferToString,\n  Row,\n  RowSet,\n  Column,\n  ParseOptions,\n} from './ImportUtils'\n\nconst vcfCoreColumns: { name: string; type: string }[] = [\n  { name: 'CHROM', type: 'Text' }, // 0\n  { name: 'POS', type: 'Number' }, // 1\n  { name: 'ID', type: 'Text' }, // 2\n  { name: 'REF', type: 'Text' }, // 3\n  { name: 'ALT', type: 'Text' }, // 4\n  { name: 'QUAL', type: 'Number' }, // 5\n  { name: 'FILTER', type: 'Text' }, // 6\n  { name: 'INFO', type: 'Text' }, // 7\n  { name: 'FORMAT', type: 'Text' }, // 8\n]\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction vcfRecordToRow(vcfParser: any, line: string, lineNumber: number): Row {\n  const vcfVariant = vcfParser.parseLine(line)\n  const vcfFeature = new VcfFeature({\n    variant: vcfVariant,\n    parser: vcfParser,\n    id: `vcf-${lineNumber}`,\n  })\n\n  const data = line.split('\\t').map(d => (d === '.' ? '' : d))\n  // no format column, add blank\n  if (data.length === 8) {\n    data.push('')\n  }\n  const row: Row = {\n    id: String(lineNumber + 1),\n    extendedData: { vcfFeature: vcfFeature.toJSON() },\n    cells: data.map((text, columnNumber) => {\n      return {\n        columnNumber,\n        text,\n      }\n    }),\n  }\n  return row\n}\n\nexport function parseVcfBuffer(buffer: Buffer, options: ParseOptions = {}) {\n  const { selectedAssemblyName } = options\n  let { header, body } = splitVcfFileHeaderAndBody(bufferToString(buffer))\n  const rows: Row[] = []\n  const vcfParser = new VCF({ header })\n  header = '' // garbage collect\n  body.split(/\\n|\\r\\n|\\r/).forEach((line: string, lineNumber) => {\n    if (/\\S/.test(line)) {\n      rows.push(vcfRecordToRow(vcfParser, line, lineNumber))\n    }\n  })\n  body = '' // garbage collect\n\n  const rowSet: RowSet = {\n    isLoaded: true,\n    rows,\n  }\n\n  const columnDisplayOrder: number[] = []\n  const columns: Column[] = []\n  for (let i = 0; i < vcfCoreColumns.length; i += 1) {\n    columnDisplayOrder.push(i)\n    columns[i] = {\n      name: vcfCoreColumns[i].name,\n      dataType: { type: vcfCoreColumns[i].type },\n    }\n  }\n  for (let i = 0; i < vcfParser.samples.length; i += 1) {\n    const oi = vcfCoreColumns.length + i\n    columnDisplayOrder.push(oi)\n    columns[oi] = { name: vcfParser.samples[i], dataType: { type: 'Text' } }\n  }\n\n  columnDisplayOrder.push(columnDisplayOrder.length)\n  columns.unshift({\n    name: 'Location',\n    dataType: { type: 'LocString' },\n    isDerived: true,\n    derivationFunctionText: `jexl:{text:row.extendedData.vcfFeature.refName+':'\\n\n    +row.extendedData.vcfFeature.start+'..'+row.extendedData.vcfFeature.end, extendedData:\\n\n    {refName:row.extendedData.vcfFeature.refName,start:row.extendedData.vcfFeature.start,end:row.extendedData.vcfFeature.end}}`,\n  })\n\n  return {\n    rowSet,\n    columnDisplayOrder,\n    hasColumnNames: true,\n    columns,\n    assemblyName: selectedAssemblyName,\n  }\n}\n\nexport function splitVcfFileHeaderAndBody(wholeFile: string) {\n  // split into header and the rest of the file\n  let headerEndIndex = 0\n  let prevChar\n  for (; headerEndIndex < wholeFile.length; headerEndIndex += 1) {\n    const c = wholeFile[headerEndIndex]\n    if (prevChar === '\\n' && c !== '#') {\n      break\n    }\n    prevChar = c\n  }\n\n  return {\n    header: wholeFile.slice(0, Math.max(0, headerEndIndex)),\n    body: wholeFile.slice(headerEndIndex),\n  }\n}\n"],"names":["bufferToString","buffer","TextDecoder","fatal","decode","async","parseWith","options","arguments","length","undefined","then","module","default","noheader","output","fromString","guessColumnType","rowSet","columnNumber","isValidRefName","_parsedLoc","text","rows","cells","parsedLoc","guessedType","parseLocString","error","refName","start","test","dataToSpreadsheetSnapshot","hasColumnNameLine","columnNameLineNumber","selectedAssemblyName","maxCols","isLoaded","map","row","rowNumber","id","String","columnNames","colNamesRow","splice","forEach","cell","columns","columnDisplayOrder","push","extendedData","name","dataType","type","hasColumnNames","assemblyName","parseCsvBuffer","parseTsvBuffer","delimiter","vcfCoreColumns","parseVcfBuffer","header","body","splitVcfFileHeaderAndBody","vcfParser","VCF","split","line","lineNumber","vcfVariant","parseLine","vcfFeature","VcfFeature","variant","parser","concat","data","d","toJSON","vcfRecordToRow","i","samples","oi","unshift","isDerived","derivationFunctionText","wholeFile","prevChar","headerEndIndex","c","slice","Math","max"],"sourceRoot":""}