{"version":3,"file":"static/js/8258.f0aee51f.chunk.js","mappings":"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","sources":["../../../plugins/bed/src/BedpeAdapter/BedpeAdapter.ts"],"sourcesContent":["import {\n  BaseFeatureDataAdapter,\n  BaseOptions,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport { Region, Feature, SimpleFeature } from '@jbrowse/core/util'\nimport IntervalTree from '@flatten-js/interval-tree'\nimport { unzip } from '@gmod/bgzf-filehandle'\n\nfunction isGzip(buf: Buffer) {\n  return buf[0] === 31 && buf[1] === 139 && buf[2] === 8\n}\n\nexport function featureData(\n  line: string,\n  uniqueId: string,\n  flip: boolean,\n  names?: string[],\n) {\n  const l = line.split('\\t')\n  const ref1 = l[flip ? 3 : 0]\n  const start1 = +l[flip ? 4 : 1]\n  const end1 = +l[flip ? 5 : 2]\n  const ref2 = l[!flip ? 3 : 0]\n  const start2 = +l[!flip ? 4 : 1]\n  const end2 = +l[!flip ? 5 : 2]\n  const name = l[6]\n  const score = +l[7]\n  const strand1 = parseStrand(l[8])\n  const strand2 = parseStrand(l[9])\n  const extra = l.slice(10)\n  const rest = names\n    ? Object.fromEntries(names.slice(10).map((n, idx) => [n, extra[idx]]))\n    : extra\n  let ALT\n  if (['DUP', 'TRA', 'INV', 'CNV', 'DEL'].includes(extra[0])) {\n    ALT = `<${extra[0]}>`\n  }\n\n  return new SimpleFeature({\n    start: start1,\n    end: end1,\n    refName: ref1,\n    ...(ALT ? { ALT: [ALT] } : {}), // it's an array in VCF\n    strand: strand1,\n    name,\n    ...rest,\n    score,\n    uniqueId,\n    mate: { refName: ref2, start: start2, end: end2, strand: strand2 },\n  })\n}\n\nfunction parseStrand(strand: string) {\n  if (strand === '+') {\n    return 1\n  } else if (strand === '-') {\n    return -1\n  } else if (strand === '.') {\n    return 0\n  } else {\n    return undefined\n  }\n}\n\nexport default class BedpeAdapter extends BaseFeatureDataAdapter {\n  protected bedpeFeatures?: Promise<{\n    header: string\n    feats1: Record<string, string[] | undefined>\n    feats2: Record<string, string[] | undefined>\n    columnNames: string[]\n  }>\n\n  protected intervalTrees: Record<\n    string,\n    Promise<IntervalTree | undefined> | undefined\n  > = {}\n\n  public static capabilities = ['getFeatures', 'getRefNames']\n\n  private async loadDataP(opts: BaseOptions = {}) {\n    const pm = this.pluginManager\n    const bedLoc = this.getConf('bedpeLocation')\n    const buf = await openLocation(bedLoc, pm).readFile(opts)\n    const buffer = isGzip(buf) ? await unzip(buf) : buf\n    // 512MB  max chrome string length is 512MB\n    if (buffer.length > 536_870_888) {\n      throw new Error('Data exceeds maximum string length (512MB)')\n    }\n    const data = new TextDecoder('utf8', { fatal: true }).decode(buffer)\n    const lines = data.split(/\\n|\\r\\n|\\r/).filter(f => !!f)\n    const headerLines = []\n    let i = 0\n    for (; i < lines.length && lines[i].startsWith('#'); i++) {\n      headerLines.push(lines[i])\n    }\n    const header = headerLines.join('\\n')\n    const feats1 = {} as Record<string, string[] | undefined>\n    const feats2 = {} as Record<string, string[] | undefined>\n    for (; i < lines.length; i++) {\n      const line = lines[i]\n      const cols = line.split('\\t')\n      const r1 = cols[0]\n      const r2 = cols[3]\n      if (!feats1[r1]) {\n        feats1[r1] = []\n      }\n      if (!feats2[r2]) {\n        feats2[r2] = []\n      }\n      feats1[r1]!.push(line)\n      feats2[r2]!.push(line)\n    }\n    const columnNames = this.getConf('columnNames')\n\n    return {\n      header,\n      feats1,\n      feats2,\n      columnNames,\n    }\n  }\n\n  private async loadData(opts: BaseOptions = {}) {\n    if (!this.bedpeFeatures) {\n      this.bedpeFeatures = this.loadDataP(opts).catch(e => {\n        this.bedpeFeatures = undefined\n        throw e\n      })\n    }\n\n    return this.bedpeFeatures\n  }\n\n  public async getRefNames(opts: BaseOptions = {}) {\n    const { feats1, feats2 } = await this.loadData(opts)\n    return [...new Set([...Object.keys(feats1), ...Object.keys(feats2)])]\n  }\n\n  async getHeader(opts: BaseOptions = {}) {\n    const { header } = await this.loadData(opts)\n    return header\n  }\n\n  async getNames() {\n    const { header, columnNames } = await this.loadData()\n    if (columnNames.length) {\n      return columnNames\n    }\n    const defs = header.split(/\\n|\\r\\n|\\r/).filter(f => !!f)\n    const defline = defs.at(-1)\n    return defline?.includes('\\t')\n      ? defline\n          .slice(1)\n          .split('\\t')\n          .map(field => field.trim())\n      : undefined\n  }\n\n  private async loadFeatureTreeP(refName: string) {\n    const { feats1, feats2 } = await this.loadData()\n    const names = await this.getNames()\n    const intervalTree = new IntervalTree()\n    const ret1 =\n      feats1[refName]?.map((f, i) =>\n        featureData(f, `${this.id}-${refName}-${i}-r1`, false, names),\n      ) ?? []\n    const ret2 =\n      feats2[refName]?.map((f, i) =>\n        featureData(f, `${this.id}-${refName}-${i}-r2`, true, names),\n      ) ?? []\n\n    for (const obj of [...ret1, ...ret2]) {\n      intervalTree.insert([obj.get('start'), obj.get('end')], obj)\n    }\n\n    return intervalTree\n  }\n\n  private async loadFeatureTree(refName: string) {\n    if (!this.intervalTrees[refName]) {\n      this.intervalTrees[refName] = this.loadFeatureTreeP(refName).catch(e => {\n        this.intervalTrees[refName] = undefined\n        throw e\n      })\n    }\n    return this.intervalTrees[refName]\n  }\n\n  public getFeatures(query: Region, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      const { start, end, refName } = query\n      const intervalTree = await this.loadFeatureTree(refName)\n      intervalTree?.search([start, end]).forEach(f => observer.next(f))\n      observer.complete()\n    }, opts.signal)\n  }\n\n  public freeResources(): void {}\n}\n"],"names":["featureData","line","uniqueId","flip","names","l","split","ref1","start1","end1","ref2","start2","end2","name","score","strand1","parseStrand","strand2","extra","slice","rest","Object","fromEntries","map","n","idx","ALT","includes","concat","SimpleFeature","start","end","refName","strand","mate","BedpeAdapter","BaseFeatureDataAdapter","constructor","arguments","bedpeFeatures","intervalTrees","loadDataP","opts","length","undefined","pm","this","pluginManager","bedLoc","getConf","buf","openLocation","readFile","buffer","isGzip","unzip","Error","lines","TextDecoder","fatal","decode","filter","f","headerLines","i","startsWith","push","header","join","feats1","feats2","cols","r1","r2","columnNames","loadData","catch","e","getRefNames","Set","keys","getHeader","getNames","defline","at","field","trim","loadFeatureTreeP","_feats1$refName$map","_feats1$refName","_feats2$refName$map","_feats2$refName","intervalTree","IntervalTree","ret1","id","ret2","obj","insert","get","loadFeatureTree","getFeatures","query","ObservableCreate","async","search","forEach","observer","next","complete","signal","freeResources","capabilities"],"sourceRoot":""}